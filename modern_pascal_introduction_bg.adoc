# Модерен обектен Паскал - Въведение за програмисти
Michalis Kamburelis
include::locale/attributes-bg.adoc[]
:toc: left
:toclevels: 4
:sectnums:
:source-highlighter: coderay
:docinfo1:

++++
<style>
body { font-family: "Open Sans", "DejaVu Sans", sans-serif; }
</style>
++++

## Защо

Има много книги и ресурси за Паскал, но в повечето от тях се говори само за стария Паскал, който е без класове, модулиfootnote:unit[модул = Unit] или генерициfootnote:generics[генерици = Generics].
// В някои от тях се говори за Паскал, преди той дори да има класове. Някои от тях показват класове, както са направени в Делфи, но не споменават по -съвременни функции, като генерици.

Затова написах бързо въведение в това, което аз наричам *модерен Обектен Паскал*. Повечето от програмистите, които го използват, всъщност не го наричат така. Просто го наричаме _"нашия Паскал"_. Но чувствам, че когато представям езика е важно да подчертая, че е вече модерен, обектно-ориентиран език. Той се е развил *значително* от времето на стария (Turbo) Паскал, който много хора са учили преди време в училище. Функционално е доста подобен на C++, Java или C#.

* Той има всички съвременни функции, които можете да очаквате - класове, модули, интерфейсиfootnote:interface[интерфейс = Interface], генерици ...
* Той се компилира директно до бърз машинен код,
* Той е типово обезопасен,
* Той е език от високо ниво, но също така може да е и от ниско ако желаете.

Освен това има отличен преносим компилатор с отворен код, наречен _Free Pascal Compiler_, http://freepascal.org/ . Има и придружаващо IDE (редактор, Debugger, библиотека от визуални компоненти, дизайнер на форми), наречен _Lazarus_ http://lazarus.freepascal.org/ . Самият аз съм автор на _Castle Game Engine_, https://castle-engine.io/ , която е 3D и 2D библиотека с отворен код, използваща Паскал за създаване на игри на много платформи (Windows, Linux, macOS, Android, iOS, Nintendo Switch; подготвя се и WebGL).

Това въведение е насочено най-вече към програмисти, които вече имат опит в програмирането на други езици. Тук няма да разглеждаме значенията на някои универсални концепции като _"Какво е клас"_, само ще покажем как да ги използваме в Паскал.

## Основи

### Програма "Hello world"

[source,pascal]
----
include::code-samples/hello_world.lpr[]
----

Това е завършена програма, която можете да _компилирате_ и _стартирате_.

* Ако използвате FPC на командния ред, просто създайте нов файл `myprogram.lpr` и изпълнете `fpc myprogram.lpr`.
* Ако използвате _Lazarus_, създайте нов проект (меню _Project_ -> _New Project_ -> _Simple Program_). Запазете го като `myProgram` и поставете по-горния код като основен файл. Компилирайте го с помощта на командата от менюто _Run -> Compile_.
* Това е програма за командния ред, така че и в двата случая -- просто стартирайте компилирания изпълним файл от командния ред.

Останалата част от тази книга говори за езика Обектен Паскал, така че не очаквайте да видите нещо по-забавно от програми за команден ред. Ако искате да видите нещо готино, просто създайте нов GUI проект в _Lazarus_ (_Project_ -> _New Project_ -> _Application_).
//Поиграйте си наоколо, пуснете няколко бутони във формата, боравете се с техните събития (като `OnClick`).
Готово -- работещо GUI риложение, крос-платформа, с естествен вид навсякъде, използвайки удобна библиотека с визуални компоненти. _Lazarus_ и _Free Pascal Compiler_ се предлагат с много готови модули за работа в мрежа, GUI, база данни, файлови формати (XML, JSON, изображения ...), многозадачност и всичко останало, от което може да се нуждаете. Вече споменах своя готин _Castle Game Engine_ по-рано:)
// Библиотеките, създадени на други езици (DLL, so, dylib), могат лесно да се използват и от FPC (и за повечето от тях ще намерите готови "заглавни" модули и дори модули, които ги "опаковат" в по-модерни обектно-ориентирани API).

### Функции, процедури, примитивни типове

[source,pascal]
----
include::code-samples/functions_primitives.lpr[]
----

За да върнете стойност от функция, задайте стойност на магическата променлива `Result`. Можете да четете и присвоявате свободно `Result`, точно както и всяка друга локална променлива.

[source,pascal]
----
function MyFunction(const S: string): string;
begin
  Result := S + 'something';
  Result := Result + ' something more!';
  Result := Result + ' and more!';
end;
----

Можете също да използвате и името на функцията (`MyFunction` в горния пример) като променлива, на която да присвоите резултата. Но не бих го препоръчал в нов код, тъй като изглежда "съмнително", когато се използва в дясната страна на оператор за присвояване. Просто използвайте `Result` винаги, когато искате да прочетете или да зададете резултата от функцията.

Разбира се може да го направите ако искате да извикате функцията рекурсивно. Ако извиквате рекурсивно функция без параметри, уверете се, че сте сложили скобите  `()` след името (въпреки че в Паскал обикновено можете да ги пропуснете в този случай). Това ще направи рекурсивното извикване на функция без параметри различимо от прочитането на текущата стойност на функцията. Например така:

[source,pascal]
----
function SumIntegersUntilZero: Integer;
var
  I: Integer;
begin
  Readln(I);
  Result := I;
  if I <> 0 then
    Result := Result + SumIntegersUntilZero();
end;
----

Можете да извикате `Exit` за да приключите изпълнението на процедурата или функцията преди тя да е достигнала последния си `end;`. Ако извикате `Exit` без параметри във функция, тогава ще се върне последното нещо присвоено на `Result`. Може да се използва и конструкцията `Exit(X)`, за да се зададе резултата от функцията и да се излезе *сега* -- точно както `return X` в C-подобните езици.

[source,pascal]
----
function AddName(const ExistingNames, NewName: string): string;
begin
  if ExistingNames = '' then
    Exit(NewName);
  Result := ExistingNames + ', ' + NewName;
end;
----

Обърнете внимание, че резултатът от функцията може да бъде игнориран. Всяка функция може да се използва и като процедура. Това има смисъл, когато функцията има някакъв _страничен ефект_ (напр. променя глобална променлива) вместо да изчислява резултат. Например:

[source,pascal]
----
var
  Count: Integer;
  MyCount: Integer;

function CountMe: Integer;
begin
  Inc(Count);
  Result := Count;
end;

begin
  Count := 10;
  CountMe; // the function result is discarded, but the function is executed, Count is now 11
  MyCount := CountMe; // use the result of the function, MyCount equals to Count which is now 12
end.
----

### Проверки (if)

Използвайте `if .. then` или `if .. then .. else` за да изпълните някакъв код, когато е удовлетворено определено условие. За разлика от C-подобните езици, в Паскал не е необходимо да ограждате условието в скоби.

[source,pascal]
----
var
  A: Integer;
  B: boolean;
begin
  if A > 0 then
    DoSomething;

  if A > 0 then
  begin
    DoSomething;
    AndDoSomethingMore;
  end;

  if A > 10 then
    DoSomething
  else
    DoSomethingElse;

  // equivalent to above
  B := A > 10;
  if B then
    DoSomething
  else
    DoSomethingElse;
end;
----

Клаузата `else` се отнася към последния `if`. Така че следното ще работи, както очаквате:

[source,pascal]
----
if A <> 0 then
  if B <> 0 then
    AIsNonzeroAndBToo
  else
    AIsNonzeroButBIsZero;
----

Въпреки че горния пример с вложени `if` е коректен, винаги в такива случаи е по-добре вложения `if` да се огради в `begin` ... `end` блок. Това прави кода по-очевиден за читателя и той ще остане очевиден, дори ако объркате отстъпа отляво. По-долу е подобрената версия на горния пример. Когато добавите или премахнете някоя клауза `else` в долния код, винаги ще е очевидно към кое условие ще бъде тя (към проверката на `A` или към проверката на `B`), така че е по-малко вероятно да се допуснат грешки.

[source,pascal]
----
if A <> 0 then
begin
  if B <> 0 then
    AIsNonzeroAndBToo
  else
    AIsNonzeroButBIsZero;
end;
----

### Логически, релационни и побитови оператори

_Логически оператори_ се наричат `and`, `or`, `not`, `xor`. Тяхното значение вероятно е очевидно (потърсете _"exclusive or"_ ако не сте сигурни какво върши _xor_ :)). Те вземат _boolean аргументи_ и връщат _boolean_. Те също могат да действат и като _побитови оператори_ когато и двата аргумента са цели числа, в този случай те връщат цяло число.

_Релационни (сравнителни)_ оператори са `=`, `<>`, `>`, `<`, `\<=`, `>=`. Ако сте свикнали с C-подобни езици, обърнете внимание, че в Паскал сравнението на две стойности (проверката дали са равни), се прави като използвате само един символ на равенство `A = B` (За разлика от C, където използвате два `A == B`). Специалният оператор _assignment_ в Паскал е `:=`.

_Логическите (или побитовите) оператори имат по-висок приоритет от релационните оператори_. Може да се наложи да използвате скоби около някои изрази, за да получите желания ред на изчисление.

Например това е грешка при компилация:

[source,pascal]
----
var
  A, B: Integer;
begin
  if A = 0 and B <> 0 then ... // INCORRECT example
----

Горното не успява да се компилира, тъй като първо компилаторът иска да изпълни побитовия `and` в средата на израза: `(0 and B)`. Това е побитова операция, която връща цяло число. След това компилатора изпълнява оператора `=`, чийто резултат е логическа стойност `A = (0 and B)`. Накрая се получава грешка _"type mismatch"_ след опита да се сравни логическата стойност `A = (0 and B)` и цялото число `0`.

Това е вярно:

[source,pascal]
----
var
  A, B: Integer;
begin
  if (A = 0) and (B <> 0) then ...
----

В изчислението на логически изрази се използва т.н. _кратко оценяване_ (short-circuit evaluation). Разглеждаме следния израз:

[source,pascal]
----
if MyFunction(X) and MyOtherFunction(Y) then...
----

* Гарантирано е, че `MyFunction(X)` ще бъде оценен първо.
* Ако `MyFunction(X)` върне `false`, тогава стойността на израза е известна (стойността на `false and каквото_и_да_е` е винаги `false`), и `MyOtherFunction(Y)` няма да се извика изобщо.
* Подобно е правилото и за  `or` изрази. Тогава, ако израза е ясно, че е `true` (защото първия операнд е `true`), втория операнд не се оценява.
* Това е особено полезно, когато пишете изрази като
+
[source,pascal]
----
if (A <> nil) and A.IsValid then...
----
+
Това ще работи, дори когато `A` е `nil`. Ключовата дума `nil` е за указател, равен на нула (когато е представен като число). Нарича се _null pointer_ в много други езици за програмиране.

// * Using `and` between two boolean values is a logical `and`, and the result is boolean. In other words, the result is `true` only if both operands are `true`, otherwise it's `false`.

// * Using `and` between two integer values is a bit-wise `and`, and the result is integer. The operands are converted to have the same number of bits, and a similar rule is performed bit-by-bit, setting each bit to `0` or `1`. If you do this with potentially negative integer values, you should understand how negative numbers are encoded in memory (_"two's complement"_).

### Тестване на единичен израз за множество стойности (case)

Ако трябва да се изпълни различно действие в зависимост от стойността на някакъв израз, тогава е полезна конструкцията `case .. of .. end`.

[source,pascal]
----
case SomeValue of
  0: DoSomething;
  1: DoSomethingElse;
  2: begin
       IfItsTwoThenDoThis;
       AndAlsoDoThis;
     end;
  3..10: DoSomethingInCaseItsInThisRange;
  11, 21, 31: AndDoSomethingForTheseSpecialValues;
  else DoSomethingInCaseOfUnexpectedValue;
end;
----

Клаузата `else` е незадължителна (и съответства на `default` в C-подобните езици). Когато нито една стойност не съвпада и не е зададена `else` клауза, тогава не се изпълнява нищо.

Ако познавате C-подобни езици и сравните това с оператор `switch`, ще забележите, че няма автоматично _пропадане_ (fall-through). Това е умишлена благодат в Паскал. Не е нужно да помните и да поставяте инструкции `break`. При всяко изпълнение, се изпълнява _най-много един_ клон на `case`, това е всичко.

### Изброени и редни типове, множества и масиви с постоянна дължина 

Изброеният тип в Паскал е много удобен, непрозрачен тип. Вероятно ще го използвате много по-често от enums в другите езици:)

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
----

Прието е пред имената в изброения тип да се сложи двубуквен префикс от името на типа, оттук `ak` = префикс за _"Animal Kind"_. Това е полезно правило, тъй като имената на изброения тип са в глобалното пространство от имена. Така че ако им сложите префикс `ak`, вие намалявате възможността за конфликт с други идентификатори.

ЗАБЕЛЕЖКА: Конфликтите в имената не са фатални. Възможно е различните модули да дефинират един и същ идентификатор. Но е добра идея да се опитате да избягвате конфликтите така или иначе, за да поддържате кода лесен за разбиране и анализ.

ЗАБЕЛЕЖКА: Можете да избегнете дефинирането на имената от изброения тип в глобалното пространство от имена чрез компилаторната директива `{$scopedenums on}`. Това означава, че ще трябва да ги указвате винаги квалифицирани по име на тип, напр. `TAnimalKind.akDuck`. В такъв случай нуждата от префикс `ak` отпада и вероятно тогава просто ще ги наречете `Duck, Cat, Dog`. Това е подобно на C# enums.

Фактът, че изброения тип е _непрозрачен_ означава, че не е възможно да се присвои директно към и от целочислен тип. Ако това е необходимо, може да се използва `Ord(MyAnimalKind)` за да се преобразува изброен тип към целочислен, или `TAnimalKind(MyInteger)` за да се преобразува целочислен тип към изброен. В последния случай първо се уверете, че `MyInteger` е в диапазона (0 to `Ord(High(TAnimalKind))`).

Изброените и редните типове могат да се използват за индекси на масиви:

[source,pascal]
----
type
  TArrayOfTenStrings = array [0..9] of string;
  TArrayOfTenStrings1Based = array [1..10] of string;

  TMyNumber = 0..9;
  TAlsoArrayOfTenStrings = array [TMyNumber] of string;

  TAnimalKind = (akDuck, akCat, akDog);
  TAnimalNames = array [TAnimalKind] of string;
----

Те също могат да се използват за създаване на множества (побитови полета):

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
  TAnimals = set of TAnimalKind;
var
  A: TAnimals;
begin
  A := [];
  A := [akDuck, akCat];
  A := A + [akDog];
  A := A * [akCat, akDog];
  Include(A, akDuck);
  Exclude(A, akDuck);
end;
----

### Цикли (for, while, repeat, for .. in)

[source,pascal]
----
include::code-samples/loops.lpr[]
----

*Относно циклите `repeat` и `while`*:

Има две разлики между тези типове цикли:

1. Условието за цикъл има противоположен смисъл. В цикъла `while .. do` условито казва _кога да се продължи_, но в `repeat .. until` условието казва _кога да се спре_.
2. При цикъла `repeat`, _условието не се проверява в началото_. По този начин цикъла `repeat` винаги се изпълнява поне веднъж.

*Относно цикъл `for I := ...`*:

Цикълът `for I := .. to .. do ...` е близък до C-подобния цикъл `for`. Въпреки това е по-ограничен, защото не може да му се укаже произволно действие и/или произволно условие за контрол на цикъла. Той може да се изпълнява само с последователни числа (или други бройни типове). Единствената различна ъзможност е тази, че може да се използва `downto` вместо `to`, за да се брои наобратно.

За сметка на това той изглежда прост и изпълнението му е силно оптимизирано. По-конкретно _изразите за горната и долната граници се изчисляват само веднъж_ преди цикъла да започне.

Обърнете внимание, че стойността на променливата на брояча на цикъла (в примера `I`) се счита за _неопределена_ след приключването на цикъла заради възможните оптимизации. Прочитане на стойността на `I` след цикъла може да доведе до издаване на предупреждение от компилатора. В случай обаче на предсрочно излизане с `Break` или `Exit` променливата гарантирано запазва последната си стойност. 

*Относно цикъл  `for I in ...`*:

Цикълът `for I in .. do ..` е подобен на `foreach` в повечето модерни езици за програмиране. Той може да работи с много от вградените типове:

* Може да се изпълни за всички стойности в масив (горния пример).
* Може да се изпълни за всички стойности на изброен тип:
+
[source,pascal]
----
var
  AK: TAnimalKind;
begin
  for AK in TAnimalKind do...
----
* Може да се изпълни за всички елементи включени в множество:
+
[source,pascal]
----
var
  Animals: TAnimals;
  AK: TAnimalKind;
begin
  Animals := [akDog, akCat];
  for AK in Animals do ...
----
* И работи с потребителски типове списъци, включително генерици, като `TObjectList` or `TFPGObjectList`.
+
[source,pascal]
----
include::code-samples/for_in_list.lpr[]
----
+
Все още не сме обяснили концепцията за класовете, така че последният пример може да не е очевиден. Просто продължете и ще стане ясно по-късно :)

### Изпечатване на информация, логове

За изпечатване на низове в Паскал, използвайте процедурите `Write` или `WriteLn`. Във втората автоматично се добавя символ за нов ред накрая.

Това е "вълшебна" процедура в Паскал. Тя може да приеме променлив брой аргументи и те могат да имат почти всякакъв тип. Всички подадени аргументи се преобразуват в низове при изпечатването, със специален синтаксис за определяне ширината на полето и броя десетични цифри след запетаята.

[source,pascal]
----
WriteLn('Hello world!');
WriteLn('You can output an integer: ', 3 * 4);
WriteLn('You can pad an integer: ', 666:10);
WriteLn('You can output a float: ', Pi:1:4);
----

За да вмъкнете изрично нов ред в низа, използвайте константата `LineEnding` (от FPC RTL). (_Castle Game Engine_ също дефинира по-кратката константа `NL`.) Паскал не интерпретира никакви специални поредици в низовете, така че изписването на

[source,pascal]
----
WriteLn('One line.\nSecond line.'); // INCORRECT example
----

Не работи така, както някои от вас биха си очаквали. Ще работи това:

[source,pascal]
----
WriteLn('One line.' + LineEnding + 'Second line.');
----

или това:

[source,pascal]
----
WriteLn('One line.');
WriteLn('Second line.');
----

Обърнете внимание, че това ще работи само в _конзолно_ приложение. Уверете се, че имате дефиниция `{$apptype CONSOLE}` (и *не* `{$apptype GUI}`) в основния файл на програмата. В някои операционни системи няма значение и винаги ще работи (Unix), но на други (Windows) опита за изпечатване с `Write` или `WriteLn` в GUI приложение ще предизвика грешка.

*В Castle Game Engine:* използвайте `WriteLnLog` или `WriteLnWarning` вместо `WriteLn` за печат на диагностична информация. Те винаги ще бъдат насочени към някакво полезно устройство или файл. В Unix, стандартния изход. В Windows GUI приложение ще бъде лог-файл. В Android ще бъде _Android logging facility_ (може да се чете с `adb logcat`). Използването на `WriteLn` трябва да се ограничи до случаите, в които се пишат конзолни приложения (напримел 3D моделен конвертор / генератор) и знаете, че  _стандартния изход_ съществува.

### Преобразуване в низ

За конвертиране на произволен брой аргументи в низ (вместо просто директно да ги извеждате) съществуват няколко възможности.

* Може да конвертирате определени типове в низ като използвате специализираните функции като `IntToStr` и `FloatToStr`. Освен това, в Паскал да можете да конкатенирате (свързвате) низове просто като използвате оператора за събиране. По този начин можете да съдадете низ подобен на следния: `'My int number is ' + IntToStr(MyInt) + ', and the value of Pi is ' + FloatToStr(Pi)`.
** _Предимство_: Изключително удобно. Съществува множество готови функции `XxxToStr` и подобни на тях (например `FormatFloat`), покриващи  много типове. Повечето от тях са в модула `SysUtils`.
// They give you a lot of flexibility in formatting.
** _Друго предимство_: Почти винаги съществува и обратна функция. За конвертиране на низ (например въведена от потребителя) обратно до цяло число или до число с плаваща запетая, може да се използват `StrToInt`, `StrToFloat` и подобни на тях (например `StrToIntDef`).
** _Недостатък_: Дълга конкатенация от много извиквания на `XxxToStr` и низове не не изглежда красиво.
//For classes, they can override the `TObject.ToString` method.
//It doesn't have that clean _separation of pattern and arguments_ property of `Format` call.

* Функцията `Format`, използва се по следния начин: `Format('%d %f %s', [MyInt, MyFloat, MyString])`. Това е подобна на функцията `sprintf` в C-подобните езици. Тя вмъква аргументите си на зададените места в указания шаблон. Така зададените места може да използват специален синтаксис за уточняване на формата, напр. `%.4f` означава число с плаваща запетая с 4 знака след запетаята.
** _Предимство_: Разделянето на _шаблона_ от _аргументите_ изглежда по-чисто и спретнато. Ако искате да промените _шаблона_ без да закачате аргументите (напр. при езиков превод), лесно може да го направите.
** _Друго предимство_: Няма никаква компилаторна магия. Може да използвате същия синтаксис за да подадете всякакъв брой аргументи от произволен тип в собствените си подпрограми (декларирайте параметър като `array of const`). След това можете да предадете тези аргументи надолу към `Format`, или да разчлените листа с аргументи и да правите каквото си искате с тях.
** _Недостатък_: Компилатора не проверява дали шаблона съвпада с броя и типа на аргументите. Използването на неподходящ синтаксис на конкретното място в шаблона ще предизвика грешка по време на изпълнение (изключение `EConvertError` а не нещо гадно като грешка в сегментацията).
//Note that, unlike the C `sprintf`, the correctness at runtime can be completely verified (there are no dirty pointer tricks inside

* `WriteStr(TargetString, ...)` процедурата работи по същия начин както `Write(...)`, с изключение на това, че резултата се записва в  `TargetString` вместо да се отпечати.
** _Предимство_: Поддържа всички функционалности на `Write`, включително специалния синтаксис за форматиране за ширина на полето и знаци след запетаята, напр. `Pi:1:4`.
** _Недостатък_: Синтаксиса за форматиране е като "компилаторна магия", направена конкретно за процедури като тази. Това понякога е проблем, защото не можете да направите собствена процедура `MyStringFormatter(...)`, която да позволява използването на нещо подобно на `Pi:1:4`. Поради тази причина (и защото дълго време не е била имплементирана в основните Паскал компилатори), конструкцията не е много популярна.

## Модули (Unit-и)

Unit-ите позволяват групиране на общи елементи (всички, които могат да се декларират), за използване от други unit-и и програми. Те са еквиваленти на _модулите_ и _пакетите_ в други езици за програмиране. Имат секция _interface_, където се декларират елементите достъпни за използване от другите unit-и и програми и секция _implementation_ където е описано как тези елементи работят. Може да запишете unit-а `MyUnit` под името `myunit.pas` (малки букви с разширение `.pas`).

[source,pascal]
----
include::code-samples/myunit.pas[]
----

Основната програма се записва обикновено под име `myprogram.lpr` (`lpr` = Lazarus program file; в Delphi обикновено се използва `.dpr`). Трябва да се отбележи, че са възможни и други разширения, някои проекти използват `.pas` за основната програма, някои използват `.pp` за unit-и или програми. Аз препоръчвам използването на `.pas` за unit-и и `.lpr` за FPC/Lazarus програми.

Програма може да използва unit със служебната дума `uses`:

[source,pascal]
----
include::code-samples/myunit_test.lpr[]
----

Unit-а може да съдържа секции `initialization` и `finalization`. Кода в тези секции се изпълнява когато програмата стартира или респективно -- приключва.

[source,pascal]
----
include::code-samples/initialization_finalization.pas[]
----

### Unit-и, които се използват взаимно

Един unit може да използва друг unit. Другия unit може да се използва в секцията interface или само в секцията implementation. Първото позволява да се дефинират нови публикувани елементи (процедури, типове,...) на базата на вече известните от другия unit. Второто е по-лимитирано, т.е. ако използвате unit само в секцията implementation, неговите идентификатори важат само в нея.

[source,pascal]
----
include::code-samples/anotherunit.pas[]
----

Не е позволено да има _кръгови зависимости между unit-и_ в техния интерфейс. Това означава, че не може два unit-а да се използват взаимно в секцията interface.
//that everything must be declared before it's used.
Причината за това е, че за да "разбере" 
//(e.g. determine the memory layout of all the structures)
интерфейсната част на даден unit, компилатора трябва първо да "разбере" интерфейсната част на всички други unit-и, които той използва. Езикът Паскал спазва това правило много стриктно и това позволява бързата компилация и автоматичното определяне _какво е нужно да се прекомпилира_. Няма необходимост да се използват сложни файлове ``Makefile`` за простата задача по компилирането, както и също няма нужда от _прекомпилиране на всичко_ само за да се уверим, че всички зависимости са се обновили правилно.
//, but also makes circular dependencies _between units interfaces_ impossible.
//(That said, this constraint is not existing in some other languages. You can actually do parsing without "complete understanding" of your dependencies, just some stuff will have to be resolved later, e.g. at linking. You can also "repeat" the compilation until your knowledge is "settled". Anyway, you have to live with this constraint now, and enjoy fast compilation times.:)

Напълно е възможно кръговото използване на unit-и при условие, че _поне единият от тях се използва в секция implementation_. Така например unit `A` може да използва `B` в секцията си interface а от друга страна unit `B` може да използва  unit `A` в секцията си implementation.

### Квалифициране на идентификаторите с името на unit-а

Различни unit-и може да дефинират един и същи идентификатор. За да бъде кода прост за четене и търсене, това би трябвало да се избягва но не винаги е възможно.
// in some situations (e.g. when you use a third-party library).
В тези случаи обикновено "печели" последния включен unit в клаузата `uses`, което означава че неговите идентификатори скриват тези със същите имена от предишните unit-и.

Винаги може да укажете изрично unit-а за даден идентификатор като използвате името на unit-а пред него разделено с точка `MyUnit.MyIdentifier`. Това е стандартното решение за ситуации, в които желания идентификатор от `MyUnit` е скрит от друг unit. Разбира се може също да промените реда на unit-ите в клаузата uses, но пък това ще засегне и всички други дефинирани идентификатори.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
program showcolor;

// Both Graphics and GoogleMapsEngine units define TColor type.
uses Graphics, GoogleMapsEngine;

var
  { This doesn't work like we want, as TColor ends up
    being defined by GoogleMapsEngine. }
  // Color: TColor;
  { This works Ok. }
  Color: Graphics.TColor;
begin
  Color := clYellow;
  WriteLn(Red(Color), ' ', Green(Color), ' ', Blue(Color));
end.
----

За unit-ите трябва да се запомни, че имат две `uses` клаузи: едната в част interface и другата в част implementation. Правилото _следващите unit-и скриват идентификаторите на предишните_ се прилага навсякъде, което означава и че _unit-ите използвани в част implementation_ могат да скрият идентификатори от unit-и _използвани в секция interface_. От друга страна, факта че за секция `interface` имат значение само unit-ите използвани в interface, може да доведе до объркващи ситуации, в които привидно еднакви декларации се приемат за различни от компилатора: 

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

// INCORRECT example

interface

uses Graphics;

procedure ShowColor(const Color: TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: TColor);
begin
  // WriteLn(ColorToString(Color));
end;

end.
----

В unit `Graphics` (от Lazarus LCL) се дефинира тип `TColor`. Но компилатора няма да компилира горния unit, твърдейки че не сте написали тяло на процедурата `ShowColor`, която да отговаря на декларацията в interface. Проблемът е че unit `GoogleMapsEngine` също дефинира тип с името `TColor`. Понеже се използва само в секция `implementation`, тази дефиниция _засенчва_ дефиницията `TColor` само в implementation. Еквивалентната версия на горния unit, където грешката е очевидна, би изглеждала така:

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

// INCORRECT example.
// This is what the compiler "sees" when trying to compile previous example

interface

uses Graphics;

procedure ShowColor(const Color: Graphics.TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: GoogleMapsEngine.TColor);
begin
  // WriteLn(ColorToString(Color));
end;

end.
----

Решението на проблема в случая е просто -- укажете изрично в implementaton да се използва `TColor` от unit `Graphics`. Може и да го оправите като преместите `GoogleMapsEngine` в секция interface преди `Graphics`. Това обаче ще доведе до други последици в unit-а `UnitUsingColors` защото ще се отрази на всичките му дефиниции.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

interface

uses Graphics;

procedure ShowColor(const Color: TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: Graphics.TColor);
begin
  // WriteLn(ColorToString(Color));
end;

end.
----

### Представяне на идентификаторите от един unit чрез друг

Понякога искате да вземете идентификатор от един unit и да го _представите_ чрез друг. Крайният резултат трябва да бъде, че когато исползвате новия unit, стария идентификатор ще бъде достъпен в пространството на имената.

Понякога това е необходимо за да се запази съвместимостта с по-стари версии на unit-а. А понякога е удобно да се "скрие" някой unit само за вътрешно ползване.

Това може да се направи с повторна дефиниция на идентификатора в новия unit.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit MyUnit;

interface

uses Graphics;

type
  { Expose TColor from Graphics unit as TMyColor. }
  TMyColor = TColor;

  { Alternatively, expose it under the same name.
    Qualify with unit name in this case, otherwise
    we would refer to ourselves with "TColor = TColor" definition. }
  TColor = Graphics.TColor;

const
  { This works with constants too. }
  clYellow = Graphics.clYellow;
  clBlue = Graphics.clBlue;

implementation

end.
----

Трябва да се отбележи, че този трик не може така лесно да се направи с глобалните процедури, функции и променливи. С процедурите и функциите можете да обявите константен указател към процедура в друг unit (виж <<Callbacks>>), но това изглежда доста "мръснишко".
// AI: The meaning of that is not clear for me ... needs clarification... 

Обикновено решението се състои в създаване на "опаковъчни" функции, които просто извикват старите от вътрешния unit, като им подават параметрите и връщат резултата.

За да се направи нещо подобно с глобалните променливи, може да се използват глобални свойства (unit-level properties), виж <<Properties>>.

## Класове

### Основи

В Паскал се използват класове (classes). На базово ниво класовете са просто контейнери за:

* _полета (fields)_ (друго име за _"променлива вътре в класа"_),
* _методи (methods)_ (друго име за _"процедура или функция вътре в класа"_),
* и _свойства (properties)_ (удобен синтаксис за нещо, което е подобно на поле, но всъщност е двойка методи за _четене (get)_ и _запис (set)_ на някаква стойност; повече за това в <<Properties>>).
* Общо казано, в един клас може да се вместят много други неща, повече е описано в <<More stuff inside classes and nested classes>>.

[source,pascal]
----
type
  TMyClass = class
    MyInt: Integer; // this is a field
    property MyIntProperty: Integer read MyInt write MyInt; // this is a property
    procedure MyMethod; // this is a method
  end;

procedure TMyClass.MyMethod;
begin
  WriteLn(MyInt + 10);
end;
----

### Наследяване, проверка (is), конверсия на типа (as)

Паскал поддържа _наследяване_ на класове и _виртуални_ методи.

[source,pascal]
----
include::code-samples/inheritance.lpr[]
----

По подразбиране методите не са виртуални, за да бъдат такива трябва да се декларират със запазената дума `virtual`. Подмяната на виртуален метод трябва да се декларира с `override`, в противен случай ще се изведе предупреждение. За да скриете метод без да го подменяте трябва да се използва думата `reintroduce` (обикновено това не се прави без основателна причина).

За да се провери какъв е класа на обектна инстанция по време на изпълнение се използва оператора `is`. За да се смени типа на инстанция, т.е. да се конвертира до друг клас, се използва оператора  `as`.

[source,pascal]
----
include::code-samples/is_as.lpr[]
----

Вместо `X as TMyClass`, може да използвате и конвертиране _без проверка_ `TMyClass(X)`. Това е по-бързо от предишното, но резултата може да доведе до неопределено поведение ако `X` не се явява наследник на `TMyClass`. Поради тази причина не използвайте `TMyClass(X)`, освен ако не е абсолютно сигурно, че `X` е наследник на `TMyClass`, например ако преди това сте проверили с `is`:

[source,pascal]
----
if A is TMyClass then
  (A as TMyClass).CallSomeMethodOfMyClass;
// below is marginally faster
if A is TMyClass then
  TMyClass(A).CallSomeMethodOfMyClass;
----

### Свойства

Свойствата са много удобна _"синтактична захар"_ (б.пр. syntax sugar - особеност на синтаксиса, която не влияе на поведението на програмата, но прави използването на езика по-удобно) за:

1. Нещо да изглежда като поле (да може да се чете и записва) но под него да има методи за четене (_getter_) и запис (_setter_). Често се използва за получаване на странични ефекти (напр. обновяване на екрана) всеки път когато стойността се промени;
2. Нещо да изглежда като поле, но да е само за четене. В резултат на това полето е подобно на константа или функция без аргументи.

[source,pascal]
----
type
  TWebPage = class
  private
    FURL: string;
    FColor: TColor;
    function SetColor(const Value: TColor);
  public
    { No way to set it directly.
      Call the Load method, like Load('http://www.freepascal.org/'),
      to load a page and set this property. }
    property URL: string read FURL;
    procedure Load(const AnURL: string);
    property Color: TColor read FColor write SetColor;
  end;

procedure TWebPage.Load(const AnURL: string);
begin
  FURL := AnURL;
  NetworkingComponent.LoadWebPage(AnURL);
end;

function TWebPage.SetColor(const Value: TColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    // for example, cause some update each time value changes
    Repaint;
    // as another example, make sure that some underlying instance,
    // like a "RenderingComponent" (whatever that is),
    // has a synchronized value of Color.
    RenderingComponent.Color := Value;
  end;
end;
----

// { compare with the old value, to shield from making
//   useless assignments to RenderingComponent.Color.
//   This is a common approach to guarantee that setting WebPage.Color
//   many times to the same value will be fast,
//   even if setting RenderingComponent.Color many times to the same value
//   would be slow. }

Забележете, че вместо да се укаже метод, може да се укаже и име на поле (обикновено частно поле) за директно четене или запис. В горния пример, свойството `Color` използва метод за запис (_setter_ `SetColor`. Но за прочитане на стойността свойството `Color` указва директно към частното поле `FColor`. Указването на поле е по-бързо отколкото изписването на тривиален метод за четене или запис. По-бързо е за писане а също така и се изпълнява по-бързо.

Когато се декларира свойство трябва да се укаже:

. Дали може да се чете и как (с директен достъп до поле или с извикване на метод `getter`);
. И съответно -- дали може да се записва и как (с директен достъп до поле или с използване на метод `setter`).

Компилатора проверява дали типовете на указаните полета и методи съответстват на типа на свойството. Например, за да прочетете `Integer` свойство, трябва да укажете или поле от тип `Integer` или метод без параметри, който връща `Integer`.

Технически, за компилатора методите "getter" и "setter" са просто нормални методи и могат да правят абсолютно всичко (включително странични ефекти или рандомизация). Но е добра практика свойствата да се проектират така, че да се държат повече или по-малко като полета:

// There are some good conventions to follow when creating properties. These are only conventions, the compiler doesn't prevent you from making something weird using properties -- f. But the good
// They should be somewhat predictable, like fields:

* Функцията _getter_ не би трябвало да има видими странични ефекти (напр. не трябва да чете от файл или от клавиатурата). Четенето трябва да е детерминистично (без рандомизация, дори псевдо-рандомизация :). Многократното четене на свойство трябва да връща една и съща стойност ако нищо не се е променило междувременно. 
+
Напълно в реда на нещата е _getter_ да има някакви _невидими_ странични ефекти, например да съхрани стойностите от някакво изчисление за да се ускори изпълнението при следващо извикване. Това е една от полезните функции на методите "getter".

* Функцията _setter_ трябва винаги да запише подадената стойност, по такъв начин, че извикването на _getter_ да я върне обратно. Не бива некоректните стойности автоматично да се игнорират в "setter", в такива случаи е редно да се предизвика изключение (exception). Не е добре също стойността да се конвертира или мащабира. Идеята е, че след `MyClass.MyProperty := 123;` програмиста трябва да очаква, че `MyClass.MyProperty = 123`.

* Свойствата само за четене, _read-only properties_, често се използват за да е възможно само четенето на някое поле отвън. Отново, добрата практика е това свойство да се държи като константа или поне като константа за това състояние на обекта. Стойността не бива да се променя неочаквано. _Ако четенето предизвиква странични ефекти или се връща случайна стойност, вместо свойство трябва да се използва функция_.

* Полето, към което се обръща свойството трябва винаги да е _private_ защото идеята на свойството е да "капсулира" целия външен достъп до него.

* Технически е възможно да се направи свойство само за запис, _set-only property_, но още не съм видял добър пример за какво може да послужи такова свойство :)

NOTE: Свойствата могат да се дефинират и извън клас, на ниво unit. Такива свойства служат за аналогични цели -- изглеждат като глобални променливи, но четенето и записа им извиква указаните подпрограми за _getter_ и _setter_.

#### Сериализация на свойства

_Пуликуваните свойства_ са база за _сериализацията_ (или _streaming components_) в Паскал. _Сериализация_ означава, че данните на инстанцията от даден клас се записва в поток (_stream_, подобно на файл), от който може по-късно да се прочете обратно.

Сериализирането е това, което се случва, когато Lazarus чете (или записва) състоянието на компонент във файл `xxx.lfm`. (В Delphi еквивалентния файл има разширение `.dfm`). Този механизъм може да се използва и за други цели с помощта на процедури като `ReadComponentFromTextStream` от unit `LResources`. Също така може да се използват и други сериализационни алгоритми, например от unit `FpJsonRtti` (сериализация в JSON формат).

В *Castle Game Engine*: Използвайте unit `CastleComponentSerialize` (базиран на `FpJsonRtti`) за да сериализирате нашите компоненти като user-interface и transformation component hierarchies.

За всяко свойство може да се декларират допълнителни полезни неща за алгоритъма за сериализация:

* Може да укажете подразбираща се стойност за свойството (с резервираната дума `default`). Обърнете внимание, че така или иначе в конструктора е необходимо да се инициализира това свойство с тази конкретна стойност по подразбиране. Това не се прави автоматично. Декларацията `default` е само информативна за сериализиращия алгоритъм: _"когато конструктора се изпълни, даденото свойство има дадената стойност"_.

* Дали свойството трябва да се записва изобщо (с резервираната дума `stored`).

### Изключения - Кратък пример

В Паскал може да се предизвикват и обработват изключения. Обработката се прави с клаузи `try ... except ... end`, също така има и финални секции `try ... finally ... end`.

[source,pascal]
----
include::code-samples/exception_finally.lpr[]
----

Обърнете внимание, че клаузата `finally` се изпълнява дори ако излезете от блок с използването на `Exit` (от функция / процедура /метод) или `Break` или `Continue` (от тялото на цикъл).

Виж глава <<Exceptions>> за по-задълбочено описание на _изключенията_.

### Нива на видимост

Както в повечето обектно-ориентирани езици, в Паскал има спецификатори за ограничаване на видимостта на полета / методи / свойства.

Основните нива на видимост са:

`public`:: всеки може да го достъпи, в това число и кода от други unit-и.
`private`:: достъпно само в този клас.
`protected`:: достъпно само в този клас и наследниците му.

Даденото по-горе обяснение за `private` и `protected` не е напълно вярно. Кодът _в същия unit_ може да прескача ограничението и да достъпва неща, които са указани като `private` или `protected`. Понякога това е удобно, тъй като позволява създаване на по-силно свързани класове. Използвайте `strict private` или `strict protected` за да обезопасите вашите класове още по-стриктно. По-подробно това е описано в <<Private and strict private>>.

Ако не укажете видимост, по подразбиране се приема `public`. Изключение се прави за класовете компилирани с `{$M+}`, или наследници на класове компилирани с `{$M+}`, което включва всички наследници на `TPersistent`, също така включва и всички наследници на `TComponent` (защото `TComponent` е наследник на `TPersistent`). За тях видимостта по подразбиране е `published`, което е като `public`, но с допълнението, че системата за сериализация знае как да ги обработва.

Не всяко поле и свойство може да бъде в секция `published` (не веки тип може да се сериализира и само класове от прости полета могат да се сериализират). Просто използвайте `public`, ако не ви е грижа за сериализацията, но искате нещо да е достъпно за всички ползватели.

### Предшественик по подразбиране

Ако не декларирате предшестващ клас, то по подразбиране се приема, че се наследява класа `TObject`.

### Self

Резервираната дума `Self` (аз) може да се използва в реализацията на класа за да укаже изрично, че става дума за вашата собствена инстанция. Това е еквивалент на `this` от C++, Java и подобни езици.

### Извикване на наследен метод

В рамките на реализация на метод, ако извикате друг метод, тогава по подразбиране вие извиквате метода на вашия собствен клас. В примерния код по-долу, `TMyClass2.MyOtherMethod` извиква `MyMethod`, който в крайна сметка извиква `TMyClass2.MyMethod`.

[source,pascal]
----
include::code-samples/method_calls_inheritance_1.lpr[]
----

Ако метода не е дефиниран за дадения клас, тогава се извиква метод от предшестващия клас. If the method is not defined in a given class, then it calls the method of an ancestor class. Всъщност, когато извикате `MyMethod` на инстация от `TMyClass2`, тогава

* Компилатора търси `TMyClass2.MyMethod`.
* Ако не го намери, търси `TMyClass1.MyMethod`.
* Ако не го намери, търси `TObject.MyMethod`.
* Ако не го намери, дава грешка при компилация.

Може да го проверите като сложите коментар пред дефиницията на `TMyClass2.MyMethod` в по-горния пример. Като резултат от извикването на `TMyClass2.MyOtherMethod` ще се извика `TMyClass1.MyMethod`.

Понякога не искате да извиквате метода на собствения си клас а аскате да извикате метода на предшественик (или предшественик на предшественик и т.н). За да направите това, добавете ключовата дума `inherited` преди извикването на `MyMethod` по следния начин:

[source,pascal]
----
inherited MyMethod;
----

По този начин вие _насилвате_ компилаторът да започне да търси от предшестващия клас. В нашия пример това означава, че компилаторът търси `MyMethod` в `TMyClass1.MyMethod`, след това `TObject.MyMethod` и след това се отказва. Дори и не обмисля използването на `TMyClass2.MyMethod`.

TIP: Променете `TMyClass2.MyOtherMethod` така, че да използва `inherited MyMethod` и вижте каква ще е разликата в резултата.

Най-често извикването на наследен метод се използва от метода със същото име в наследника. По този начин наследника може да допълни и подобри предшественика запазвайки неговата функционалност вместо да я подмени изцяло. Както в примера по-долу.

[source,pascal]
----
include::code-samples/method_calls_inherited.lpr[]
----

Понеже използването на `inherited` за извикване на метод със същото име и аргументи се среща много често, има специален съкратен вариант: може да напишете само `inherited;` (ключовата дума `inherited`, следвана непосредствено от точка и запетая, вместо името на метод). Това означава "_извикай наследения метод със същото име, предавайки му същите аргументи както на текущия метод_".

TIP: В горния пример, всички извиквания на `inherited ...;` могат да се заменят просто с `inherited;`.

Бележка 1: Този `inherited;` е наистина съкращение на извикването на наследения метод със _същите параметри_. Ако вече сте променили стойностите на параметрите (което е напълно възможно ако не са `const`), тогава наследения метод може да получи различни входни стойности от вашия наследник. Разгледайте следното:

[source,pascal]
----
procedure TMyClass2.MyMethod(A: Integer);
begin
  Writeln('TMyClass2.MyMethod beginning ', A);
  A := 456;
  { This calls TMyClass1.MyMethod with A = 456,
    regardless of the A value passed to this method (TMyClass2.MyMethod). }
  inherited;
  Writeln('TMyClass2.MyMethod ending ', A);
end;
----

Бележка 2: Когато много класове дефинират метода `MyMethod` (по "_веригата на наследяване_") обикновено той се прави _виртуален_. Повече за виртуалните методи има в раздела по-долу. Но ключовата дума `inherited` работи независимо дали методът е виртуален или не. `inherited` винаги означава, че компилаторът започва да търси метода в предшественика и има смисъл както за _виртуални_, така и за _не виртуални_ методи.  

[[virtual-methods-section]]
### Виртуални методи, подмяна и скриване

По подразбиране методите _не са виртуални_. Това е както в езика C++ и за разлика от Java.

Когато методът _не е виртуален_, компилаторът определя кой метод да се извика въз основа на текущия _деклариран_ тип клас, а не въз основа на _действително създадения_ тип клас. Разликата изглежда незначителна, но е важно, когато променливата ви е декларирана, че е от клас `TFruit`, но всъщност може да е от клас-наследник например `TApple`.

Идеята на обектно-ориентираното програмиране е, че _класът-наследник винаги е добър поне колкото наследения_, така че компилатора позволява използването на наследник винаги когато се очаква някой от предшествениците му. Когато един метод _не е виртуален_, това може да доведе до нежелани последици. Разгледайте следния случай:

[source,pascal]
----
include::code-samples/without_virtual_methods.lpr[]
----

Този пример ще се отпечата

----
We have a fruit with class TApple
We eat it:
Eating a fruit
----

Всъщност извикването `Fruit.Eat` извиква имплементацията на `TFruit.Eat` и нищо не извика имплементацията на `TApple.Eat`.

Ако се замислите как работи компилатора, това ще ви се стори естествено: когато написахте `Fruit.Eat`, променливата `Fruit` бе декларирана от тип `TFruit`. Компилаторът търси метод наречен `Eat` в класа `TFruit`. Ако класът `TFruit` не съдържа такъв метод, компилаторът ще търси в предшественика (`TObject` в този случай). Но компилаторът _не може да търси в наследници (като `TApple`)_, тъй като не знае дали _действителният клас_ на `Fruit` е `TApple`, `TFruit` или някакъв друг наследник на `TFruit` (като `TOrange`, не е показан в примера по-горе).

С други думи, _методът, който ще бъде извикан_, се определя по време на компилиране.

Използването на _виртуалните методи_ променя това поведение. *Ако методът `Eat` е виртуален* (пример за него е показан по-долу), тогава действителната метод, която ще бъде извикан, се определя _по време на изпълнение_. Ако променливата `Fruit` съдържа екземпляр на класа `TApple` (дори ако променливата е декларирана като `TFruit`), тогава методът `Eat` ще бъде потърсен първо в `TApple`.

В Обектния Паскал, за да дефинирате метод като _виртуален_, трябва да:

* Маркирайте първата му дефиниция (в най-горния предшественик) с ключовата дума `virtual`.
* Маркирайте всички останали дефиниции (в наследниците) с ключовата дума `override`. Всички подменени версии трябва да имат абсолютно еднакви параметри (и да връщат едни и същи типове, в случая на функции).

[source,pascal]
----
include::code-samples/with_virtual_methods.lpr[]
----

This example will print

----
We have a fruit with class TApple
We eat it:
Eating an apple
----

Вътрешно виртуалните методи работят, като използват така наречената _виртуална таблица с методи (VMT)_, свързана с всеки клас. Тази таблица е списък с указатели към виртуалните методи за този клас. Когато извиква метода `Eat`, компилаторът разглежда таблица с виртуални методи, свързана с _действителния_ клас на `Fruit`, и използва указател към конкретния метод `Eat` съхранен там.

Ако не използвате ключовата дума `override`, компилаторът ще ви предупреди, че _скривате_ виртуалния метод на предшественика с невиртуална дефиниция. Ако сте сигурни, че точно това искате да направите, можете да добавите ключова дума `reintroduce`. Но в повечето случаи e по-добре да запазите метода виртуален и да добавите ключовата дума `override`, като по този начин сте сигурни, че се извиква правилно.

## Освобождаване на паметта за класове

### Помнете да освобождавате паметта заета от инстанциите

Инстанциите на класове трябва да се освобождават ръчно. В противен случай ще се получи _изтичане на памет_. Съветвам да се използват опциите `-gl -gh` на FPC за засичане на изтичания (виж https://castle-engine.io/manual_optimization.php#section_memory ).

Забележете, че това не касае възникналите изключения. Въпреки че изрично създавате инстанция от клас, когато предизвиквате изключение (и това е напълно нормален клас и можете да създадете свои собствени класове за тази цел), то тази инстанция ще бъде освободена автоматично от вградения механизъм за обработка на изключения.

### Как да освободим паметта

За да освободите заетата памет от инстанция на клас, най-добре извикайте `FreeAndNil(A)` от unit `SysUtils` върху нея. Тази процедура ще провери дали `A` е `nil`, ако не е -- ще извика нейния деструктор (destructor) и ще и присвои стойност `nil`. Така многократното и извикване няма да доведе до грешка.

Приблизително това съответства на следното:

[source,pascal]
----
if A <> nil then
begin
  A.Destroy;
  A := nil;
end;
----

Всъщност това е доста опростено, тъй като `FreeAndNil` използва трик за да присвои `nil` на `A` *преди* да извика деструктора с подходяща препратка. Това предотвратява  определен клас грешки -- идеята е, че "външният" код никога не бива да има достъп до полуразрушено копие на инстанция от класа.

Често ще видите и да се използва метода `A.Free`, което е същото като:

[source,pascal]
----
if A <> nil then
  A.Destroy;
----

което унищожава инстанцията `A` (и освобождава заетата памет от нея) , освен ако тя е `nil`.

Забележете, че при нормални обстоятелства никога не бива да се извиква метод на инстанция, която може да е `nil`. Затова извикването `A.Free` може да изглежда подозрително на пръв поглед. may look suspicious at the first sight, if `A` can be `nil`. Методът `Free` обаче е изключение от това правило. Той прави нещо "нечисто" в тялото си -- именно проверява дали `Self <> nil`. Този трик работи само при методи, които не са виртуални (които не извикват други виртуални методи и не достъпват никакви полета).
// AI: But it calls Destroy which is actually virtual ?!?

Съветвам ви да използвате `FreeAndNil(A)` винаги, без изключения и никога да не извиквате директно метода `Free` или деструктора `Destroy`. _Castle Game Engine_ работи по този начин. Това позволява да бъдете уверени в това, че _всички препратки са или `nil`, или сочат към валидни инстанции_.
// AI: Highly debatable assertion.

### Ръчно и автоматично освобождаване

В много случаи необходимостта от освобождаване на инстанцията не е голям проблем. Вие просто пишете деструктор, който съответства на конструктора и освобождава всичко, за което е заделена памет в конструктора (или по-точно - през целия живот на инстанцията). Внимавайте да освободите всяко нещо само *веднъж*. Добра идея е да установите освободения указател на `nil`, обикновено е най-удобно да го направите, като извикате `FreeAndNil(A)`.

Пример:

[source,pascal]
----
uses SysUtils;

type
  TGun = class
  end;

  TPlayer = class
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  Gun1 := TGun.Create;
  Gun2 := TGun.Create;
end;

destructor TPlayer.Destroy;
begin
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  inherited;
end;
----

За да избегнете необходимостта от изрично освобождаване, можете също да използвате функцията за _"собственост"_ на `TComponent`. Обект, който е _нечий_ ще бъде автоматично освободен от _собственика_. Механизмът е достатъчно съобразителен и никога няма да освободи вече освободена инстанция (така че нещата ще работят правилно, дори ако ръчно освободите притежавания обект по-рано). Можем да променим предишния пример така:

[source,pascal]
----
uses SysUtils, Classes;

type
  TGun = class(TComponent)
  end;

  TPlayer = class(TComponent)
    Gun1, Gun2: TGun;
    constructor Create(AOwner: TComponent); override;
  end;

constructor TPlayer.Create(AOwner: TComponent);
begin
  inherited;
  Gun1 := TGun.Create(Self);
  Gun2 := TGun.Create(Self);
end;
----

Обърнете внимание, че тук трябва да заменим виртуалния конструктор на `TComponent`. Така че не можем да променим параметрите на конструктора. (Всъщност можете -- декларирайте нов конструктор с `reintroduce`. Но бъдете внимателни, тъй като някои функции, например тези за сериализация, все още ще използват виртуалния конструктор, така че се уверете, че работи правилно и в двата случая.)

Имайте предвид, че винаги можете да използвате за собственик `nil`. По този начин механизмът за _"собственост"_ няма да се използва за този компонент. Това има смисъл, ако трябва да използвате наследника на `TComponent`, но искате винаги да го освобождавате ръчно. За да направите това, трябва да създадете наследник на компонент като този: `ManualGun := TGun.Create(nil);`.

Друг механизъм за автоматично освобождаване е функционалността `OwnsObjects` (по подразбиране вече е `true`!) на класовете-контейнери като `TFPGObjectList` или `TObjectList`. Така че можем също да напишем:

[source,pascal]
----
uses SysUtils, Classes, FGL;

type
  TGun = class
  end;

  TGunList = specialize TFPGObjectList<TGun>;

  TPlayer = class
    Guns: TGunList;
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  // Actually, the parameter true (OwnsObjects) is already the default
  Guns := TGunList.Create(true);
  Gun1 := TGun.Create;
  Guns.Add(Gun1);
  Gun2 := TGun.Create;
  Guns.Add(Gun2);
end;

destructor TPlayer.Destroy;
begin
  { We have to take care to free the list.
    It will automatically free its contents. }
  FreeAndNil(Guns);

  { No need to free the Gun1, Gun2 anymore. It's a nice habit to set to "nil"
    their references now, as we know they are freed. In this simple class,
    with so simple destructor, it's obvious that they cannot be accessed
    anymore -- but doing this pays off in case of larger and more complicated
    destructors.

    Alternatively, we could avoid declaring Gun1 and Gun2,
    and instead use Guns[0] and Guns[1] in own code.
    Or create a method like Gun1 that returns Guns[0]. }
  Gun1 := nil;
  Gun2 := nil;
  inherited;
end;
----

Имайте предвид, че механизмът за "собственост" в този случай е сравнително прост и ще се получи грешка, ако освободите инстанция по друг начин докато тя все още присъства в списъка. Използвайте метода `Extract` за да извлечете инстанцията от него без да я освобождавате и по този начин да поемете отговорността за освобождаването й.

В *Castle Game Engine*: Наследниците на `TX3DNode` имат автоматично управление на заетата памет когато са вмъкнати като children на друг `TX3DNode`. Основният X3D възел, `TX3DRootNode`, на свой ред обикновено се притежава от `TCastleSceneCore`. Някои други обекти също имат прост механизъм за собственост - потърсете параметри и свойства, наречени `OwnsXxx`.

### Виртуалният деструктор наречен Destroy

Както видяхте в примерите по-горе, когато класът се унищожожава, се извиква неговият `деструктор`, наречен `Destroy`.

На теория можете да имате много деструктори, но на практика почти никога не е добра идея. Много по-лесно е да имате само един деструктор, наречен `Destroy`, който от своя страна се извиква от метода `Free`, той пък от своя страна се извиква от процедурата `FreeAndNil`.

Деструкторът `Destroy` в `TObject` е дефиниран като _виртуален_ метод, така че винаги трябва да го маркирате с ключовата дума `override` във всички ваши класове (тъй като всички класове произлизат от `TObject`). Това е предпоставка за правилната работа на `Free`. Спомнете си как работят виртуалните методи от <<virtual-methods-section>>.

[NOTE]
====
Тази информация за _деструкторите_ не важи за _конструкторите_.

Нормално е един клас да има множество конструктори. Обикновено всички те се наричат `Create` и имат различни параметри, но не е неправилно да има и конструктори с други имена.

Освен това конструкторът `Create` в `TObject` _не е виртуален_, така че не го маркирате с `override` в наследниците.

Това дава допълнителна гъвкавост при дефиниране на конструкторите. Често не е необходимо да ги правите виртуални, така че по подразбиране не сте принудени да го правите.

Имайте предвид обаче, че ситуацията е различна за наследниците на `TComponent`. `TComponent` дефинира виртуален конструктор `Create(AOwner: TComponent)` защото се нуждае от такъв, за да работи системата за сериализация. Когато наследявате `TComponent`, трябва да замените този конструктор (да го маркирате с ключовата дума `override`) и да извършите цялата си инициализация вътре в него. Дефинирането на допълнителни конструктори все пак е възможно, но те трябва да са само в ролята на _"помощни"_. Инстанцията трябва да работи винаги, когато е създадена с помощта _именно_ на конструктора `Create(AOwner: TComponent)`, в противен случай тя няма да бъде правилно конструирана при сериализацията. _Сериализация_ се използва напр. когато записвате и зареждате този компонент във формуляр на Lazarus.
====

### Free notification

Ако копирате препратка към инстанция, така че да имате две препратки към една и съща памет, и след това едната от тях се освободи -- другата се превръща във _"висящ указател"_. Тя не бива да се използва, тъй като сочи към памет, която вече не е заета. Достъпът до нея може да доведе до грешка по време на изпълнение или връщане на произволен "боклук" (тъй като паметта може да се използва повторно вече за други неща).

Използването на `FreeAndNil` тук вече не може да помогне. `FreeAndNil` записва `nil` само в препратката, която е получила -- няма начин да нулира автоматично всички други препратки. Разгледайте следния код:

[source,pascal]
----
var
  Obj1, Obj2: TObject;
begin
  Obj1 := TObject.Create;
  Obj2 := Obj1;
  FreeAndNil(Obj1);

  // what happens if we access Obj1 or Obj2 here?
end;
----

1. В края на този блок `Obj1` е `nil`. Ако някакъв код трябва да има достъп до него, той може надеждно да използва `if Obj1 <> nil then ...`, за да избегне извикване на методи на несъществуваща вече инстанция, като
+
[source,pascal]
----
if Obj1 <> nil then
  WriteLn(Obj1.ClassName);
----
+
Опитът за достъп до поле на нулева инстанция води до предвидимо изключение по време на изпълнение. Така че дори ако някой код не провери `Obj1 <> nil` и сляпо се обърне към полето `Obj1`, ще се получи ясно изключение по време на изпълнение.
+
Същото важи и за извикване на виртуален или невиртуален метод, който се обръща към поле на `nil` инстанция.

2. С `Obj2`, нещата не са така предвидими. Той не е `nil`, но е невалиден. Опита за обръщение към поле на ненулева невалидна инстанция 
//(or call a method that accessed a field of such instance)
ще предизвика непредвидимо поведение -- може би ще предизвика изключение (exception), а може би ще върне безсмисленни данни.

Има различни решения на проблема:

* Едно от решенията е да бъдете внимателни и да прочетете документацията. Не предполагайте нищо относно живота на инстанцията, ако е създадена от друг код. Ако клас `TCar` има поле, сочещо към някакъв екземпляр на `TWheel`, това е _конвенция_, че препратката към _wheel_ е валидна, докато препратката към _car_ съществува, и _car_ ще освободи своите _wheels_ в своя деструктор. Но това е само конвенция, документацията трябва да споменава, ако има нещо по-сложно.

* В горния пример, веднага след освобождаването на екземпляра `Obj1`, можете просто да присвоите изрично `nil` на променливата `Obj2` . Това е тривиално в такива прости случаи.

* Най-сигурното решение е да се използва механизма на клас `TComponent` за "известяване при освобождаване". Един компонент може да бъде известен, когато друг току-що е освободен и по този начин неговата референция да се направи равна на `nil`.
+
По този начин получавате нещо подобно на _слаба референция_. Тя може да се справи в различни сценарии, например можете да оставите кода извън класа да зададе вашата препратка, а външният код може също да освободи екземпляра по всяко време.
+
Това изисква и двата класа да са наследници на `TComponent`. Използването му като цяло се свежда до извикване на `FreeNotification`, `RemoveFreeNotification` и замяна на `Notification`.
+
Ето пълен пример, показващ как да използвате този механизъм, заедно с конструктор/деструктор и свойство за настройка със _setter_. Понякога може да се направи и по-просто, но това е пълната версия, която винаги е правилна :)
+
[source,pascal]
----
type
  TControl = class(TComponent)
  end;

  TContainer = class(TComponent)
  private
    FSomeSpecialControl: TControl;
    procedure SetSomeSpecialControl(const Value: TControl);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    destructor Destroy; override;
    property SomeSpecialControl: TControl
      read FSomeSpecialControl write SetSomeSpecialControl;
  end;

implementation

procedure TContainer.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FSomeSpecialControl) then
    { set to nil by SetSomeSpecialControl to clean nicely }
    SomeSpecialControl := nil;
end;

procedure TContainer.SetSomeSpecialControl(const Value: TControl);
begin
  if FSomeSpecialControl <> Value then
  begin
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.RemoveFreeNotification(Self);
    FSomeSpecialControl := Value;
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.FreeNotification(Self);
  end;
end;

destructor TContainer.Destroy;
begin
  { set to nil by SetSomeSpecialControl, to detach free notification }
  SomeSpecialControl := nil;
  inherited;
end;
----

### Наблюдател за известяване при освобождаване (Castle Game Engine)

В *Castle Game Engine* препоръчваме да използвате `TFreeNotificationObserver` от модула `CastleClassUtils` вместо директно извикване на `FreeNotification`, `RemoveFreeNotification` и замяна на `Notification`.

Като цяло използването на `TFreeNotificationObserver` изглежда малко по-просто от използването на механизма `FreeNotification` директно (въпреки че признавам, че е въпрос на вкус). Но по-специално, когато _един и същи екземпляр на клас трябва да се наблюдава поради множество причини_ тогава `TFreeNotificationObserver` е много по-прост за използване (директното използване на `FreeNotification` в този случай може да стане комплицирано, тъй като трябва да внимавате да не дерегистрирате известието твърде скоро) .

Това е примерният код, използващ `TFreeNotificationObserver`, за постигане на същия ефект като примера в предишния раздел:

[source,pascal]
----
type
  TControl = class(TComponent)
  end;

  TContainer = class(TComponent)
  private
    FSomeSpecialControlObserver: TFreeNotificationObserver;
    FSomeSpecialControl: TControl;
    procedure SetSomeSpecialControl(const Value: TControl);
    procedure SomeSpecialControlFreeNotification(const Sender: TFreeNotificationObserver);
  public
    constructor Create(AOwner: TComponent); override;
    property SomeSpecialControl: TControl
      read FSomeSpecialControl write SetSomeSpecialControl;
  end;

implementation

uses CastleComponentSerialize;

constructor TContainer.Create(AOwner: TComponent);
begin
  inherited;
  FSomeSpecialControlObserver := TFreeNotificationObserver.Create(Self);
  FSomeSpecialControlObserver.OnFreeNotification := {$ifdef FPC}@{$endif} SomeSpecialControlFreeNotification;
end;

procedure TContainer.SetSomeSpecialControl(const Value: TControl);
begin
  if FSomeSpecialControl <> Value then
  begin
    FSomeSpecialControl := Value;
    FSomeSpecialControlObserver.Observed := Value;
  end;
end;

procedure TContainer.SomeSpecialControlFreeNotification(const Sender: TFreeNotificationObserver);
begin
  // set property to nil when the referenced component is freed
  SomeSpecialControl := nil;
end;
----

Вижте https://castle-engine.io/custom_components .

## Изключения

### Преглед

Изключенията позволяват _прекъсване на нормалното изпълнение на кода_.

- Във всеки момент от програмата можете да *предизвикате* изключение, като използвате ключовата дума `raise`. На практика редовете код, следващи извикването `raise ...`, няма да се изпълнят.

- Изключение може да бъде *прихванато* с помощта на конструкция `try ... except ... end`. Прихващането на изключение означава, че по някакъв начин ще се "справите" с изключението и следващият код трябва да се изпълни както обикновено, изключението повече няма да се разпространява нагоре.
+
Забележка: Ако бъде предизвикано изключение, но то никога не е уловено, това ще доведе до спиране на цялото приложение с грешка.
+
** Но в LCL приложенията изключенията около събития (events) винаги се улавят (и извеждат в LCL диалогов прозорец), ако предварително не ги прихванете.
** В _Castle Game Engine_ приложения, използващи `CastleWindow`, изключенията около вашите събития винаги се прихващат по същия начин (и се показва правилния диалогов прозорец).
** Така че не е толкова лесно да се предизвика изключение, което _не е прихванато никъде_ (не е прихванато във вашия код, в LCL код, в CGE код...).

- Въпреки че изключенията прекъсват изпълнението, можете да използвате конструкцията `try ... finally ... end`, за да изпълните някакъв код *винаги*, дори ако кодът е бил прекъснат от изключение.
+
Конструкцията `try ... finally ... end` също сработва, когато кодът е прекъснат от ключови думи `Break` или `Continue` или `Exit`. Въпросът е кода в секцията `finally` да се изпълнява наистина _винаги_.

Като цяло "изключение" може да бъде инстанция от всеки един клас.

- Компилаторът не налага никой конкретен клас. Просто трябва да извикате `raise XXX`, където `XXX` е екземпляр от какъвто и да е клас (така че всичко, произлизащо от `TObject` става за целта).

- Стандартна конвенция за класовете от изключения е те да наследяват специалния клас `Exception`. Класът `Exception` наследява `TObject`, като добавя свойството низ `Message` и конструктор за лесно задаване на това свойство. Всички изключения, предизвикани от стандартната библиотека, наследяват `Exception`. Съветваме ви да следвате тази конвенция.

- Класовете с изключение (по конвенция) имат имена, които започват с `E`, не с `T`. Например `ESomethingBadHappened`.

- Компилаторът автоматично ще освободи обекта-изключение, когато той бъде обработен. Не го освобождавайте сами.
+
В повечето случаи вие просто конструирате обекта в същото време, когато извиквате `raise`, например `raise ESomethingBadHappened.Create('Описание на случилото се лошо нещо.')`.

### Предизвикване

Ако искате да предизвикате свое собствено изключение, декларирайте го и извикайте `raise ...`, когато е подходящо:

[source,pascal]
----
type
  EInvalidParameter = class(Exception);

function ReadParameter: String;
begin
  Result := Readln;
  if Pos(' ', Result) <> 0 then
    raise EInvalidParameter.Create('Invalid parameter, space is not allowed');
end;
----

Обърнете внимание, че изразът след `raise` трябва да бъде валиден екземпляр на клас. Почти винаги ще създавате екземпляра за изключение тук.

Можете също да използвате конструктора `CreateFmt`, който е удобно съкращение на `Create(Format(MessageFormat, MessageArguments))`. Това е обичаен начин за предоставяне на повече информация в съобщението за изключение. Можем да подобрим предишния пример така:

[source,pascal]
----
type
  EInvalidParameter = class(Exception);

function ReadParameter: String;
begin
  Result := Readln;
  if Pos(' ', Result) <> 0 then
    raise EInvalidParameter.CreateFmt('Invalid parameter %s, space is not allowed', [Result]);
end;
----

### Прихващане

Можете да прихванете изключение така:

[source,pascal]
----
var
  Parameter1, Parameter2, Parameter3: String;
begin
  try
    Writeln('Input 1st parameter:');
    Parameter1 := ReadParameter;
    Writeln('Input 2nd parameter:');
    Parameter2 := ReadParameter;
    Writeln('Input 3rd parameter:');
    Parameter3 := ReadParameter;
  except
    // capture EInvalidParameter raised by one of the above ReadParameter calls
    on EInvalidParameter do
      Writeln('EInvalidParameter exception occurred');
  end;
end;
----

За да подобрим горния пример, можем да декларираме име за инстанцията на изключение (ще използваме `E` в примера). По този начин можем да отпечатаме съобщението за грешка:

[source,pascal]
----
try
...
except
  on E: EInvalidParameter do
    Writeln('EInvalidParameter exception occurred with message: ' + E.Message);
end;
----

Може също да се тества за множество изключения:

[source,pascal]
----
try
...
except
  on E: EInvalidParameter do
    Writeln('EInvalidParameter exception occurred with message: ' + E.Message);
  on E: ESomeOtherException do
    Writeln('ESomeOtherException exception occurred with message: ' + E.Message);
end;
----

Можете също така да отработите и произволно предизвикано изключение, ако не използвате никакъв израз `on`:

[source,pascal]
----
try
...
except
  Writeln('Warning: Some exception occurred');
end;
// WARNING: DO NOT FOLLOW THIS EXAMPLE WITHOUT READING A WARNING BELOW
// ABOUT "CAPTURING ALL EXCEPTIONS"
----

Като цяло _трябва да прихванете само изключения от определен клас, които сигнализират за определен проблем, с който знаете как да се справите_. Бъдете внимателни с прихващането на изключения от общ тип (като всяко `Exception` или всеки `TObject`), тъй като лесно можете да уловите прекалено много и по-късно да причините проблеми при отстраняване на други грешки. Както във всички езици за програмиране с изключения, доброто правило, което трябва да следвате, е _никога да не прихващате изключение, с което не знаете как да се справите_. По-специално, не прихващайте изключение само за да отстраните проблема, без първо да проучите _защо_ възниква изключението.

- Изключението показва ли проблем при въвеждането от потребителя? Тогава трябва да го докладвате на потребителя.

- Изключението показва ли грешка във вашия код? Тогава трябва да поправите кода, за да не се случва повече изключението.

Друг начин да прихванете всички изключения е да използвате:

[source,pascal]
----
try
...
except
  on E: TObject do
    Writeln('Warning: Some exception occurred');
end;
// WARNING: DO NOT FOLLOW THIS EXAMPLE WITHOUT READING A WARNING ABOVE
// ABOUT "CAPTURING ALL EXCEPTIONS"
----

Въпреки че обикновено е достатъчно да се прихване само `Exception`:

[source,pascal]
----
try
...
except
  on E: Exception do
    Writeln('Warning: Some exception occurred: ' + E.ClassName + ', message: ' + E.Message);
end;
// WARNING: DO NOT FOLLOW THIS EXAMPLE WITHOUT READING A WARNING ABOVE
// ABOUT "CAPTURING ALL EXCEPTIONS"
----

Можете да "предизвикате отново" изключението в блока `except ... end`, ако е необходимо. Можете да извикате `raise E;`, ако инстанцията е `E`, можете също така просто да използвате `raise` без параметър. Например:

[source,pascal]
----
try
...
except
  on E: EInvalidSoundFile do
  begin
    if E.InvalidUrl = 'http://example.com/blablah.wav' then
      Writeln('Warning: loading http://example.com/blablah.wav failed, ignore it')
    else
      raise;
  end;
end;
----

Имайте предвид, че въпреки че изключението е екземпляр на обект, никога не бива да го освобождавате ръчно. Компилаторът ще генерира подходящ код, който гарантира освобождаването след като бъде обработен.

### Finally (изпълнение на код независимо дали има изключение)

Често се използва конструкцията `try .. finally .. end`, за освобождаване на екземпляр от някакъв клас, независимо дали е възникнало изключение при използването му. Начинът за използване е следния:

[source,pascal]
----
procedure MyProcedure;
var
  MyInstance: TMyClass;
begin
  MyInstance := TMyClass.Create;
  try
    MyInstance.DoSomething;
    MyInstance.DoSomethingElse;
  finally
    FreeAndNil(MyInstance);
  end;
end;
----

Това работи надеждно винаги и не причинява изтичане на памет, дори ако `MyInstance.DoSomething` или `MyInstance.DoSomethingElse` предизвикат изключение.

Обърнете внимание, че това взема предвид, че локалните променливи, като `MyInstance` по-горе, имат недефинирани стойности (може да съдържат случаен "боклук в паметта") преди първото присвояване. Тоест, писането на нещо подобно _не_ би било вярно:

[source,pascal]
----
// INCORRECT EXAMPLE:
procedure MyProcedure;
var
  MyInstance: TMyClass;
begin
  try
    CallSomeOtherProcedure;
    MyInstance := TMyClass.Create;
    MyInstance.DoSomething;
    MyInstance.DoSomethingElse;
  finally
    FreeAndNil(MyInstance);
  end;
end;
----

Горният пример е грешен: ако възникне изключение в `TMyClass.Create` (конструктора може също да предизвика изключение) или в рамките на `CallSomeOtherProcedure`, тогава променливата `MyInstance` не се инициализира. Извикването на `FreeAndNil(MyInstance)` ще се опита да извика деструктора на `MyInstance`, което най-вероятно ще се срине с _Access Violation (Segmentation Fault)_. Всъщност едно изключение ще причини друго изключение, което ще направи съобщението за грешка безполезно: няма да видите съобщението на първото изключение.

Понякога е оправдано да поправите горния код, като първо инициализирате всички локални променливи на `nil` (тогава извикването на `FreeAndNil` е безопасно). Това има смисъл, ако освождавате *много* екземпляри на класове. Така че двата примера по-долу работят еднакво добре:

[source,pascal]
----
procedure MyProcedure;
var
  MyInstance1: TMyClass1;
  MyInstance2: TMyClass2;
  MyInstance3: TMyClass3;
begin
  MyInstance1 := TMyClass1.Create;
  try
    MyInstance1.DoSomething;

    MyInstance2 := TMyClass2.Create;
    try
      MyInstance2.DoSomethingElse;

      MyInstance3 := TMyClass3.Create;
      try
        MyInstance3.DoYetAnotherThing;
      finally
        FreeAndNil(MyInstance3);
      end;
    finally
      FreeAndNil(MyInstance2);
    end;
  finally
    FreeAndNil(MyInstance1);
  end;
end;
----

Вероятно това е по-четливо във вида по-долу:

[source,pascal]
----
procedure MyProcedure;
var
  MyInstance1: TMyClass1;
  MyInstance2: TMyClass2;
  MyInstance3: TMyClass3;
begin
  MyInstance1 := nil;
  MyInstance2 := nil;
  MyInstance3 := nil;
  try
    MyInstance1 := TMyClass1.Create;
    MyInstance1.DoSomething;

    MyInstance2 := TMyClass2.Create;
    MyInstance2.DoSomethingElse;

    MyInstance3 := TMyClass3.Create;
    MyInstance3.DoYetAnotherThing;
  finally
    FreeAndNil(MyInstance3);
    FreeAndNil(MyInstance2);
    FreeAndNil(MyInstance1);
  end;
end;
----

NOTE: В този прост пример можете да направите правилния довод, че кодът би трябвало да се раздели на 3 отделни процедури, като едната извиква всяка от другите две.

### Как изключенията се показват от различните библиотеки

- В случая на Lazarus LCL, изключенията, предизвикани по време на събития (различни обратни извиквания, _callbacks_, присвоени на свойствата на `OnXxx` в LCL компонентите) ще бъдат прихванати и ще доведат до диалогово съобщение, което позволява на потребителя да продължи или да спре приложението. Това означава, че вашите собствени изключения не "излизат" от `Application.ProcessMessages`, така че те не прекъсват директно приложението. Можете да конфигурирате какво точно да се случи с помощта на `TApplicationProperties.OnException`.

- По същия начин, в _Castle Game Engine_ с `CastleWindow`: изключението се прихваща вътрешно и води до съобщение за грешка. Така изключенията не "излизат" от `Application.ProcessMessages`. Отново можете да конфигурирате какво да се случва с помощта на `Application.OnException`.

- Някои други GUI библиотеки може да направят нещо подобно на горното.

- В случай на други приложения, можете да конфигурирате как се показва изключението, като присвоите глобален _callback_ на `OnHaltProgram`.

## Run-time библиотека

### Вход/изход с помощта на потоци

Съвременните програми на Паскал трябва да използват класа `TStream` и неговите наследници за да извършват входно/изходни операции. Много полезни класове наследяват `TStream`, например: `TFileStream`, `TMemoryStream`, `TStringStream`.

[source,pascal]
----
include::code-samples/file_stream.lpr[]
----

В *Castle Game Engine*: Трябва да използвате функцията `Download` за създаването на поток, който получава данни от произволен URL адрес. По този начин се поддържат обикновени файлове, HTTP и HTTPS ресурси, Android assets и други. Освен това, за да отворите ресурс във вашите данни за играта (в поддиректорията `data`), използвайте специалния URL адрес `castle-data:/xxx`. Примери:

[source,pascal]
----
EnableNetwork := true;
S := Download('https://castle-engine.io/latest.zip');
----

[source,pascal]
----
S := Download('file:///home/michalis/my_binary_file.data');
----

[source,pascal]
----
S := Download('castle-data:/gui/my_image.png');
----

За да четете текстови файлове, препоръчваме да използвате класа `TTextReader`. Той предоставя поредово API и съдържа в себе си `TStream`. Конструкторът `TTextReader` може да вземе готов URL адрес или вие можете да подадете там вашия персонализиран източник `TStream`.

[source,pascal]
----
Text := TTextReader.Create('castle-data:/my_data.txt');
try
  while not Text.Eof do
    WriteLnLog('NextLine', Text.ReadLn);
finally
  FreeAndNil(Text);
end;
----

[[generic-containers-section]]
### Контейнери (списъци, речници), използващи генерици

Езикът и run-time библиотеката предлагат различни гъвкави контейнери. Има редица "негенерични" класове (като `TList` и `TObjectList` от модула `Contnrs`), има и динамични масиви (`array of TMyType`). Но за да получите най-голяма гъвкавост *и* безопасност, съветвам за повечето от вашите нужди да използвате *генерични контейнери*.

_Генеричните контейнери_ ви дават много полезни методи за добавяне, премахване, обхождане, търсене, сортиране... Компилаторът също така знае (и проверява), че контейнерът съдържа единствено елементи от указания тип.

// Using these lists is a good idea, as you get type-safety, and their API is rich (there are methods to find, sort, iterate and so on). We discourage using _dynamic arrays_ (`array of X`, `SetLength(X, ...)`) as their API is poor (you can only use `SetLength` and your own type helpers). We discourage using `TList` or `TObjectList` as it will require casting your references from `TObject` to your type.

В момента има три библиотеки, предоставящи генерични контейнери в FPC:

* Модул `Generics.Collections` (от FPC >= 3.2.0)
* Модул `FGL`
* Модул `GVector` (включен в `fcl-stl`)

Съветваме да се използва модул `Generics.Collections`. Генерични контейнери реализирани там са:

- пакетирани с полезни функции,

- много ефективни (особено важно при достъп до речници{empty}footnote:dictionary[речник = Dictionary, a.k.a. Associative array] с помощта на ключове),

- съвместими между FPC и Delphi,

- именуването е в съответствие с другите части на стандартната библиотека (като негенеричните контейнери от модула `Contnrs`).

В *Castle Game Engine*: Ние използваме интензивно `Generics.Collections` и съветваме да използвате `Generics.Collections` и във вашите приложения!

Най-важните класове от `Generics.Collections` са:

TList:: Генеричен списък от елементи от указан тип.
TObjectList:: Генеричен списък от екземпляри от указан клас. Може да "притежава" екземплярите, което означава че ще ги унищожи автоматично.
TDictionary:: Генеричен речник{empty}footnote:dictionary[].
TObjectDictionary:: Генеричен речник, Може да "притежава" ключовете и/или стойностите.
// So (which means that they should be object instances, and will be automatically freed).

Ето как да използвате прост генеричен `TObjectList`:

[source,pascal]
----
include::code-samples/generics_lists.lpr[]
----

Обърнете внимание, че някои операции изискват сравняване на два елемента, като сортиране и търсене (напр. чрез методите `Sort` и `IndexOf`). Контейнерите в `Generics.Collections` използват за това _сравнител_. _Подразбиращия се сравнител_ е смислен за всички типове, дори за записи (в дадения случай сравнява съдържанието на паметта, което е разумна настройка по подразбиране поне за търсене чрез `IndexOf`).
// It can be customized if needed.

Когато сортирате списък, можете да укажете _персонализиран сравнител_ като параметър. _Сравнителя_ е клас, реализиращ интерфейса `IComparer`. На практика обикновено дефинирате подходящ _callback_ и използвате метода `TComparer<T>.Construct`, за да пакетирате този _callback_ в екземпляр на `IComparer`. Пример за това е по-долу:

[source,pascal]
----
include::code-samples/generics_sorting.lpr[]
----

Класът `TDictionary` реализира *речник*, познат като *map (key -> value)*, също познат като *associative array*. Неговото API е малко подобно на C# `TDictionary`. Има полезни итератори за ключове, стойности и двойки ключ->стойност.

Примерен код, използващ речник:

[source,pascal]
----
include::code-samples/generics_dictionary.lpr[]
----

`TObjectDictionary` може да _притежава_ ключовете и/или стойностите, което означава че ще ги унищожава автоматично. Внимавайте _това притежание да бъде само когато ключовете/стойностите са екземпляри на обекти_. Ако укажете, че ще се притежават елементи от друг тип, например `Integer` (т.е. ако ключовете са `Integer`, и включите `doOwnsKeys`), ще получите много неприятен срив при изпълнение на програмата.

Пример за това как се използва `TObjectDictionary` е даден по-долу. Компилирайте примера с _memory leak detection_, напр. така `fpc -gl -gh generics_object_dictionary.lpr`, за да видите, че няма изтичане на памет при приключване на програмата.

[source,pascal]
----
include::code-samples/generics_object_dictionary.lpr[]
----

Ако предпочитате да използвате модула `FGL` вместо `Generics.Collections`, най-важните класове от `FGL` са:

TFPGList:: Генеричен списък от елементи от указан тип.
TFPGObjectList:: Генеричен списък от екземпляри от указан клас. Може да "притежава" екземплярите.
TFPGMap:: Генеричен речник{empty}footnote:dictionary[].

//Use `TFPGList` for lists of primitives (or records or old-style objects), `TFPGObjectList` for a list of class instances. *In the Castle Game Engine:* You can also use `CastleGenericLists` with `TGenericStructList` for a list of records or old-style objects, this workarounds the problem of impossibility to override their operators in older FPC versions.

В модул `FGL`, `TFPGList` може да се използва само с типове, които имат дефиниран оператор за равенство (=). При `TFPGMap` за типа на ключа трябват дефинирани оператори _"по-голямо"_ (>) и _"по-малко"_ (<). Ако искате да използвате тези контейнери с типове, които нямат дефинирани оператори за сравнение (например записи), ще трябва да им дефинирате съответните оператори както е показано в <<Operator overloading>>.

В *Castle Game Engine* сме включили модул `CastleGenericLists`, който добавя класовете `TGenericStructList` и `TGenericStructMap`. Те са подобни на `TFPGList` и `TFPGMap`, но не изискват дефиниране на оператори за сравнение за съответните типове (вместо това, те сравняват съдържанието на паметта, което е често подходящо за записи или указатели). Но от версия 6.3 модула `CastleGenericLists` е маркиран като отживял (_deprecated_) и препоръчваме използването на `Generics.Collections` вместо него.

Ако искате да научите повече за генериците, вижте <<Generics>>.

### Клониране: TPersistent.Assign

Копирането на екземплярите на клас чрез прост оператор за присвояване (:=) копира единствено *препратката*.

[source,pascal]
----
var
  X, Y: TMyObject;
begin
  X := TMyObject.Create;
  Y := X;
  // X and Y are now two pointers to the same data
  Y.MyField := 123; // this also changes X.MyField
  FreeAndNil(X);
end;
----

За да копирате *съдържанието на екземпляр* от някакъв клас, стандартния подход е да наследите класа от `TPersistent`, и да подмените неговия метод `Assign`. След като бъде правилно написан за `TMyObject`, може да се използва така:

[source,pascal]
----
var
  X, Y: TMyObject;
begin
  X := TMyObject.Create;
  Y := TMyObject.Create;
  Y.Assign(X);
  Y.MyField := 123; // this does not change X.MyField
  FreeAndNil(X);
  FreeAndNil(Y);
end;
----

За да работи правилно, кодът в тялото на метода `Assign` трябва да копира стойностите на необходимите полета. Трябва внимателно да кодирате `Assign`, за да копирате от клас, който може да е наследник на текущия клас.

[source,pascal]
----
include::code-samples/persistent.lpr[]
----

Понякога е по-удобно да замените метода `AssignTo` в класa източник, вместо да замените метода `Assign` в класa, на който се присвоява.

Бъдете внимателни, когато извиквате `inherited` в подменения `Assign`. Има две ситуации:

Вашият клас е пряк наследник на класа `TPersistent`. (Или не е пряк наследник на `TPersistent`, но нито един предшественик не е заменил метода `Assign`.)::

   В този случай вашият клас трябва да използва ключовата дума `inherited` (за извикване на `TPersistent.Assign`) _само ако не можете да се справите с присвояването във вашия код_.

Вашият клас произлиза от клас, който вече е заменил метода `Assign`.::

  В този случай вашият клас трябва _винаги_ да използва ключовата дума `inherited` (за да извика наследения `Assign`). Като цяло извикването на `inherited` в подменени методи _обикновено_ е добра идея.

За да разберете причината зад горното правило (кога трябва и кога _не трябва_ да извикате `inherited` от имплементацията `Assign`) и как това е свързано с метода `AssignTo`, нека да разгледаме `TPersistent.Assign` и `TPersistent.AssignTo` реализации:

[source,pascal]
----
procedure TPersistent.Assign(Source: TPersistent);
begin
  if Source <> nil then
    Source.AssignTo(Self)
  else
    raise EConvertError...
end;

procedure TPersistent.AssignTo(Destination: TPersistent);
begin
  raise EConvertError...
end;
----

NOTE: Това не е *точната* реализация в `TPersistent`. Копиран е кода на стандартната FPC библиотека, но след това е опростен, за да се скрият маловажни подробности относно съобщението за изключение.
//The exact source code, in the FPC standard library, can be found in the `rtl/objpas/classes/persist.inc` source file. Its behavior is 100% compatible with the Delphi standard library, as far as I know.

Изводите, които можете да направите от горното са:

* _Ако нито `Assign`, нито `AssignTo` не са заменени_, извикването им ще доведе до изключение.

* Също така имайте предвид, че няма _няма_ код в изпълнението на `TPersistent`, който автоматично да копира всички полета (или всички публикувани полета) на класовете. Ето защо трябва да направите това сами, като замените `Assign` във всички класове. Можете да използвате RTTI (информация за тип на изпълнение) за това, но за прости случаи вероятно просто ще копирате полетата ръчно.

Когато имате клас като `TApple`, вашата реализация `TApple.Assign` обикновено ще се занимава с копиране на полета, които са специфични само за класа `TApple` (не за предшественика на `TApple`, като `TFruit`). И така, изпълнението на `TApple.Assign` обикновено проверява дали `Source is TApple` в началото, преди да копира полета, свързани с ябълка. След това извиква `inherited`, за да позволи на `TFruit` да обработва останалите полета.

Ако приемем, че сте написали `TFruit.Assign` и `TApple.Assign` по описания начин, тогава ефектът ще е следният:

* Ако подадете екземпляр `TApple` на `TApple.Assign`, той ще копира всички полета.
* Ако подадете екземпляр `TOrange` на `TApple.Assign`, той ще копира само общите полета на `TOrange` и `TApple`. С други думи - ще копира полетата дефинирани в `TFruit`.
* Ако подадете екземпляр `TWerewolf` на `TApple.Assign`, той ще предизвика изключение (защото `TApple.Assign` ще извика `TFruit.Assign`, който ще извика `TPersistent.Assign`, който ще предизвика изключение).

NOTE: Запомнете, че когато наследявате `TPersistent`, по подразбиране _спецификатора за видимост_ е `published`, за да се позволи сериализиране на наследниците на `TPersistent`. Не всички типове на полета и свойства са разрешени в секция `published`. Ако поради това получите грешки и не ви е грижа за сериализацията, просто променете видимостта на `public`. Вижте <<Visibility specifiers>>.

## Разни възможности на езика

### Локални (вложени) подпрограми

Вътре в по-голяма _подпрограма_ (функция, процедура, метод) може да се дефинира друга, помощна подпрограма.

//It has all the flexibility of a normal routine, it's just not
//This is quite powerful feature that allows you to _easily_ split a long routine into many smaller ones.

Вложената подпрограма може свободно да достъпва (чете и записва) всички параметри подадени на външната, _както и всички нейни локални променливи_. Това е много мощно средство, което позволява да се разбие голяма подпрограма в няколко по-малки без да е необходимо голямо усилие (тъй като не е нужно да предавате цялата необходима информация в параметрите). Внимавайте да не прекалите -- ако много вложени подпрограми използват (и дори променят) една и съща променлива на външната подпрограма, кодът може да стане труден за разчитане.

Долните два примера са еквивалентни:

[source,pascal]
----
function SumOfSquares(const N: Integer): Integer;

  function Square(const Value: Integer): Integer;
  begin
    Result := Value * Value;
  end;

var
  I: Integer;
begin
  Result := 0;
  for I := 0 to N do
    Result := Result + Square(I);
end;
----

Друга версия, в която локалната функция `Square` осъществява директен достъп до `I`:

[source,pascal]
----
function SumOfSquares(const N: Integer): Integer;
var
  I: Integer;

  function Square: Integer;
  begin
    Result := I * I;
  end;

begin
  Result := 0;
  for I := 0 to N do
    Result := Result + Square;
end;
----

Локалните процедури могат да достигнат всякаква дълбочина -- което означава, че можете да дефинирате локална процедура в друга локална процедура. Така че можете да се развихрите (но, моля, не ставайте _прекалено диви_, или кодът ще стане нечетлив:).

[[Callbacks]]

### Callbacks (познати като _Събития_, също като _Указатели към функции_, също като _Процедурни променливи_)

Позволяват индиректно извикване на подпрограми чрез променлива. Променливата може да бъде присвоена по време на изпълнение, за да сочи към всяка функция _със съвпадащи типове параметри и връщани типове_.

Callback-ът може да бъде:

* Нормален, което означава, че може да сочи към всяка обикновена подпрограма (без методи и вложени подпрограми).
+
[source,pascal]
----
include::code-samples/callbacks.lpr[]
----
* Метод: декларира се с `of object` накрая.
+
[source,pascal]
----
include::code-samples/callbacks_of_object.lpr[]
----
+
Имайте предвид, че _не можете_ да предавате глобални процедури / функции като методи. Те не са съвместими. Ако ви трябва `of object` callback, но не искате да създавате екземпляр от фиктивен клас, можете да използвате <<Class methods>> as methods.
+
[source,pascal]
----
type
  TMyMethod = function (const A, B: Integer): Integer of object;

  TMyClass = class
    class function Add(const A, B: Integer): Integer;
    class function Multiply(const A, B: Integer): Integer;
  end;

var
  M: TMyMethod;
begin
  M := @TMyClass(nil).Add;
  M := @TMyClass(nil).Multiply;
end;
----
+
За съжаление, ще трябва да изпишете грозното `@TMyClass(nil).Add` вместо просто `@TMyClass.Add`.
// AI: Not true. The latter also works.

* (Евентуално) локална подпрограма: декларирайте с `is nested` в края и се уверете, че използвате директивата `{$modeswitch nestedprocvars}`. Те вървят ръка за ръка с <<Local (nested) routines>>.

### Генерици

Генериците са мощно средство във всеки съвременен език. Дефиницията на нещо (обикновено клас) може да бъде параметризирана с друг тип. Най-типичният пример е, когато трябва да създадете контейнер (списък, речник, дърво, граф...): тогава може да дефинирате _списък елементи от тип  T_, и после _да го специализирате_ за да получите незабавно _списък от цели числа_, _списък от низове_, _списък инстанции от клас TMyRecord_ и т.н.

Генериците в Pascal работят подобно на генериците в C++. Което означава, че те се _"разширяват"_ по време на специализацията, _подобно_ на макроси (но са много по-безопасни от тях; например идентификаторите се разкриват по време на дефиницията, а не при специализацията, така че не можете да "инжектирате" някакво неочаквано поведение при специализация). На практика това означава, че те са много бързи (могат да бъдат оптимизирани за всеки отделен тип) и работят с типове от всякакъв размер. Когато специализирате генеричен тип можете да използвате примитивен тип (цяло число, float), както запис, така и клас.

// Unlike in Java, you are *not* limited to only generics of things that are a reference.

[source,pascal]
----
include::code-samples/generics.lpr[]
----

Генериците не се ограничават до класове, можете да имате и генерични функции и процедури:

[source,pascal]
----
include::code-samples/generic_functions.lpr[]
----

Вижте също <<generic-containers-section>> относно важните стандартни класове, използващи генерици.

### Overloading

Позволени са методи (също и глобални функции и процедури) с едно и също име, стига да имат различни параметри. По време на компилиране компилаторът открива кой искате да използвате, като узнае параметрите, които подавате.

По подразбиране overloading-a използва FPC подхода, което означава, че всички методи в дадено пространство от имена (клас или единица) са равнопоставени и закриват другите методи в пространства от имена с по-малък приоритет. Например, ако дефинирате клас с методи `Foo(Integer)` и `Foo(string)` и той наследява клас с метод `Foo(Float)`, тогава потребителите на вашия нов клас няма да имат достъп до метод `Foo(Float)` толкова лесно (те все още могат --- ако преобразуват класа към неговия тип-предшественик). За да преодолеете това, използвайте ключовата дума `overload`.

### Препроцесор

Можете да използвате прости препроцесорни директиви за:

* условна компилация (код зависим от платформата или други ръчно зададени параметри),
* да включите един файл в друг,
* да дефинирате макроси без параметри.

Имайте предвид, че макроси с параметри не се поддържат. Като цяло трябва да избягвате използването на препроцесорните директиви... освен ако наистина не се налага. Предварителната обработка се прави преди компилатора да извърши анализа на кода, което означава, че можете да "нарушите" нормалния синтаксис на езика Pascal. Това е мощна, но и донякъде "нечиста" функция.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit PreprocessorStuff;
interface

{$ifdef FPC}
{ This is only defined when compiled by FPC, not other compilers (like Delphi). }
procedure Foo;
{$endif}

{ Define a NewLine constant. Here you can see how the normal syntax of Pascal
  is "broken" by preprocessor directives. When you compile on Unix
  (includes Linux, Android, Mac OS X), the compiler sees this:

    const NewLine = #10;

  When you compile on Windows, the compiler sees this:

    const NewLine = #13#10;

  On other operating systems, the code will fail to compile,
  because a compiler sees this:

    const NewLine = ;

  It's a *good* thing that the compilation fails in this case -- if you
  will have to port the program to an OS that is not Unix, not Windows,
  you will be reminded by a compiler to choose the newline convention
  on that system. }

const
  NewLine =
    {$ifdef UNIX} #10 {$endif}
    {$ifdef MSWINDOWS} #13#10 {$endif} ;

{$define MY_SYMBOL}

{$ifdef MY_SYMBOL}
procedure Bar;
{$endif}

{$define CallingConventionMacro := unknown}
{$ifdef UNIX}
  {$define CallingConventionMacro := cdecl}
{$endif}
{$ifdef MSWINDOWS}
  {$define CallingConventionMacro := stdcall}
{$endif}
procedure RealProcedureName; CallingConventionMacro; external 'some_external_library';

implementation

{$include some_file.inc}
// $I is just a shortcut for $include
{$I some_other_file.inc}

end.
----

Включваните файлове обикновено имат разширение `.inc` и се използват за две цели:

* Включеният файл може да съдържа само други директиви на компилатора, които "конфигурират" вашия изходен код. Например можете да създадете файл `myconfig.inc` със следното съдържание:
+
[source,pascal]
----
{$mode objfpc}
{$H+}
{$J-}
{$modeswitch advancedrecords}
{$ifndef VER3}
  {$error This code can only be compiled using FPC version at least 3.x.}
{$endif}
----
+
Сега можете да включите този файл с помощта на `{$I myconfig.inc}` във всички ваши изходни файлове.

* Друга цел е да се раздели голям unit на много файлове, като същевременно се запази като един unit относно езиковите правила. Не прекалявайте с тази техника - първият ви инстинкт трябва да бъде да разделите един unit на множество unit-и, а не да разделяте един unit на множество включени файлове. Все пак това е полезна техника. Позволява да се избегне "експлозията" на броя на unit-ите, като същевременно поддържа вашите файлове с изходен код кратки. Например, може да е по-добре да имате единичен unit с _"често използвани UI контроли"_ отколкото да създавате _по един unit за всеки UI контролен клас_, тъй като последното би направило клаузата `uses` дълга (тъй като обикновено UI ще зависи от няколко UI класа). Но поставянето на всички тези UI класове в един файл `myunit.pas` би го направило дълъг и неудобен за навигация, така че разделянето му на множество включени файлове може да има смисъл.
//For example, *Castle Game Engine* has a unit `CastleControls` with a couple of user-interface controls, like `TCastleButton`, `TCastleLabel`, `TCastleImageControl` and more. We could split it into many units, even to _one unit per class_, as the classes are not really tightly connected. But that would often force you to have a long `uses` clause, since a lot of user-interface code will want to use a couple of control classes. So we made a practical decision to just put all _often used controls_ in a single unit.
  . Позволява лесно да имате междуплатформен интерфейс на unit с платформено-зависима реализация. По принцип можете да направите:
+
[source,pascal]
----
{$ifdef UNIX} {$I my_unix_implementation.inc} {$endif}
{$ifdef MSWINDOWS} {$I my_windows_implementation.inc} {$endif}
----
+
Понякога това е по-добре от писането на дълъг код с много `{$ifdef UNIX}`, `{$ifdef MSWINDOWS}`, примесени с нормален код (декларации на променливи, тела на подпрограми). По този начин кодът става по-четлив. Можете дори да използвате тази техника по-агресивно, като използвате опцията на командния ред `-Fi` на FPC, за да включите някои поддиректории само за определени платформи. Тогава можете да имате много версии на включения файл `{$I my platform_specific_implementation.inc}` и просто да ги включвате, позволявайки на компилатора да намери правилната версия.

### Записи

_Record_ е просто контейнер за други променливи. Това е като много, много опростен _class_: няма наследяване или виртуални методи. Това е като _struct_ в C-подобни езици.

Ако използвате директивата `{$modeswitch advancedrecords}`, записите *могат* да имат методи и спецификатори за видимост. Като цяло, тогава са възможни езикови функции, които са налични за класове и _не нарушават простото предвидимо разпределение на паметта на запис_.

[source,pascal]
----
include::code-samples/records.lpr[]
----

В съвременния Обектен Паскал първият ви мисъл трябва да бъде да проектирате "клас", а не "запис" -- защото класовете са пълни с полезни функции, като конструктори и наследяване.

Но записите все още са много полезни, когато имате нужда от скорост или предвидимо разпределение на паметта:

* Записите нямат конструктор или деструктор. Вие просто дефинирате променлива от тип запис. Има недефинирано съдържание (боклук в паметта) в началото (с изключение на автоматично управлявани типове, като низове; гарантирано е, че те ще бъдат инициализирани, така че да бъдат празни, и финализирани, за да освободят броя на препратките). Така че трябва да сте по-внимателни, когато работите със записи., Те обаче ви давар известно предимство в скоростта.
* Масивите от записи са добре линеаризирани в паметта, така че са удобни за кеширане.
* Разпределението на паметта при записите (размер, празнини между полетата) е ясно дефинирано в някои ситуации: когато поискате _C layout_ или когато използвате `packed record`. Това е полезно:
** за комуникация с библиотеки, написани на други езици за програмиране, когато предоставят API, базиран на записи,
** за четене и запис на двоични файлове,
** да правят мръсни трикове на ниско ниво (като нерестриктирано конвертиране на типове от един тип към друг, когато сте наясно с тяхното представяне в паметта).
* Записите също могат да имат `case` варианти, които работят като _unions_ в C-подобните езици. Те позволяват да се третира една и съща част от паметта като различен тип, в зависимост от вашите нужди. Това позволява по-добро използване на паметта в някои случаи. И позволява повече _мръсни, опасни трикове на ниско ниво_:)

### Обекти, стар стил

Преди време Turbo Pascal въведе друг синтаксис за функционалност, подобна на клас, използвайки ключовата дума `object`. Това е донякъде смесица между концепцията за „запис“ и модерна „класа“.

* Старите обекти могат да се създават / освобождават и по време на тези операции можете да извикате техния конструктор / деструктор.
* Но те също могат да бъдат просто декларирани и използвани, като обикновени записи. Простият тип "запис" или "обект" не е препратка (указател) към нещо друго, това са просто данни. Това ги прави удобни за малки обеми от данни, където многократното създаване и освобождаване не винаги е оправдано.
//It also makes them fast -- a list of such structures is nicely linear in memory, iterating over it doesn't involve jumping over pointers. Also, their memory layout is defined in _some_ situations (packed records, or records with C layout), which makes them suitable to pass to external APIs, like OpenGL.
* Старите обекти предлагат наследяване и виртуални методи, макар и с малки разлики от съвременните класове. Бъдете внимателни -- _лоши неща_ могат да се случат, ако се опитате да използвате обект с виртуални методи, без да извикате неговия конструктор.

В повечето случаи не се препоръчва използването на обекти от стария вид. Съвременните _класове_ предоставят много повече функционалност. Когато е необходимо да се повиши скоростта на изпълнение, могат да се използват записи (вкл. _разширени записи_).Този подход е по-добър от използването на стари обекти.

### Указатели

Можете да създадете _указател_ към всеки тип данни. Указателят към типа `TMyRecord` се декларира като `^TMyRecord` и по конвенция се нарича `PMyRecord`. По-долу е показан традиционен пример за свързан списък от цели числа, използващи записи:

[source,pascal]
----
type
  PMyRecord = ^TMyRecord;
  TMyRecord = record
    Value: Integer;
    Next: PMyRecord;
  end;
----

Обърнете внимание, че дефиницията е рекурсивна (тип `PMyRecord` се дефинира с помощта на тип `TMyRecord`, докато `TMyRecord` се дефинира с помощта на `PMyRecord`). Позволено е да се дефинира тип указател към _все още недефиниран тип_, стига той да бъде дефиниран в рамките на същия раздел `type`.

Можете да заемате и освобождавате памет за указателите с помоща на методите `New` и `Dispose` или (на по-ниско ниво, типово необезопасено) методите `GetMem` и `FreeMem`. За да достъпите данните, които указателите сочат, следва да добавите оператора `^ (например `MyInteger := MyPointerToInteger^`). За да направите обратната операция, която е _получаване на указател към съществуваща променлива_, трябва да използвате префикс-оператора `@` (например `MyPointerToInteger := @MyInteger`).

Има и нетипизиран тип `Pointer`, подобен на `void*` в C-подобните езици. Той е напълно типово необезопасен и може да бъде преобразуван във всеки друг тип указател.

Не забравяйте, че _екземплярът на class_ всъщност е указател, въпреки че не изисква оператори `^` или `@`, за да го използвате.
//That's why it's called a _reference_.
Възможно е да се направи свързан списък, използващ класове, той би бил следният:

[source,pascal]
----
type
  TMyClass = class
    Value: Integer;
    Next: TMyClass;
  end;
----

### Замяна на оператори

Можете да замените значението на много от езиковите оператори, за да позволите например събиране и умножение във вашите потребителски типове. Като например:

[source,pascal]
----
include::code-samples/operator_overloading.lpr[]
----

Също така можете да заменяте значението на оператори върху класове. Понеже в такива функции-оператори обикновено се създават нови екземпляри на класовете, в извикващия код трябва да се предвиди надлежното освобождаване на заетата памет.

[source,pascal]
----
include::code-samples/operator_overloading_classes.lpr[]
----

Можете и да замените значението на оператори върху записи. Това е по-просто отколкото да го правите върху класове, защото няма нужда да се грижите за освобождаването на заетата памет.

[source,pascal]
----
include::code-samples/operator_overloading_records.lpr[]
----

За работа със записи се препоръчва да използвате `{$modeswitch advancedrecords}` и да замените операторите като `class operator` вътре в записа. Това позволява да се използват генерични контейнери, които зависят от съществуването на някакъв оператор (като `TFPGList`, който зависи от наличието на оператор за равенство) с такива записи. В противен случай "глобалната" дефиниция на оператор (не в записа) няма да бъде открита (защото не е налична в кода, който имплементира `TFPGList`) и няма да можете да специализирате списък със `specialize TFPGList<TMyRecord>`.

[source,pascal]
----
include::code-samples/operator_overloading_records_lists.lpr[]
----

## Допълнителни възможности на класовете

### Частни и лични полета

Спецификатора `private` означава, че полето (или метода) не е достъпно извън класа, в който е декларирано. Това правило обаче позволява изключение: кодът _в същия модул_ може да работи с частни полета и методи. Някой програмист на C++ би могъл да каже, че _всички класове в един модул са "приятели"_. Това изключение често е полезно и не руши енкапсулацията защото в крайна сметка е в границите на един модул.

От друга страна, ако правите големи модули с много класове, които не са силно свързани един с друг, е по-безопасно да използвате спецификатора `strict private`. Той наистина ще ограничи достъпа до полето (или метода) само в рамките на класа. Без изключения.

Аналогично -- спецификатора `protected` означава, че полето или метода е достъпен за наследниците и "приятелите" в модула, докато `strict protected`, че е достъпно само за наследниците.

### Допълнителни декларации и вложени класове

В един клас можете да декларирате и вложени секции за константи (`const`) или типове (`type`). По този начин може дори да се декларират и вложени класове. Спецификаторите за видимост работят както винаги, в частност вложеният клас може да бъде `private`(невидим за външния свят), което доста често е полезно.
//The compiler watches that you don't break the visibility rules (for example you cannot declare a _public function_ that returns a type that is _private_).
// (I wish - it doesn't, unfortunately...)

Имайте предвид, че за да декларирате поле след константа или тип, ще трябва да започнете блок `var`.

[source,pascal]
----
type
  TMyClass = class
  private
    type
      TInternalClass = class
        Velocity: Single;
        procedure DoSomething;
      end;
    var
      FInternalClass: TInternalClass;
  public
    const
      DefaultVelocity = 100.0;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TMyClass.Create;
begin
  inherited;
  FInternalClass := TInternalClass.Create;
  FInternalClass.Velocity := DefaultVelocity;
  FInternalClass.DoSomething;
end;

destructor TMyClass.Destroy;
begin
  FreeAndNil(FInternalClass);
  inherited;
end;

{ note that method definition is prefixed with
  "TMyClass.TInternalClass" below. }
procedure TMyClass.TInternalClass.DoSomething;
begin
end;
----

### Методи на класа

Това са методи, които можете да извикате с препратка към клас (`TMyClass`), не непременно към екземпляр на клас.

[source,pascal]
----
type
  TEnemy = class
    procedure Kill;
    class procedure KillAll;
  end;

var
  E: TEnemy;
begin
  E := TEnemy.Create;
  try
    E.Kill;
  finally FreeAndNil(E) end;
  TEnemy.KillAll;
end;
----

Имайте предвид, че те също могат да бъдат виртуални - това понякога е много полезно когато се комбинират с <<Class references>>.

// The class methods namespace is limited to that of the containing class, just like regular methods.

Методите на клас съшо могат да бъдат ограничени с <<Visibility specifiers>> като `private` or `protected` съвсем като обикновените методи.

Имайте предвид, че конструкторът винаги действа като метод на клас, когато се извиква по нормален начин (`MyInstance := TMyClass.Create(...);`). Въпреки, че е възможно също така да се извика конструктор от самия клас и тогава той действа като нормален метод. Това е полезна функция за "верижни" конструктори, когато един конструктор (напр. подменен за да приеме целочислен параметър) върши нещо и след това извиква друг конструктор (напр. без параметър).

### Препратки към клас

_Препратките към клас_ ви позволяват да изберете класа по време на изпълнение, например да извикате метод на клас или конструктор, без да знаете точния клас по време на компилация. Това е тип, деклариран като `class of TMyClass`.

[source,pascal]
----
type
  TMyClass = class(TComponent)
  end;

  TMyClass1 = class(TMyClass)
  end;

  TMyClass2 = class(TMyClass)
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  // Obviously you can do this:

  C := TMyClass.Create(nil); FreeAndNil(C);
  C := TMyClass1.Create(nil); FreeAndNil(C);
  C := TMyClass2.Create(nil); FreeAndNil(C);

  // In addition, using class references, you can also do this:

  ClassRef := TMyClass;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass1;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass2;
  C := ClassRef.Create(nil); FreeAndNil(C);
end;
----

Препратките към класове могат да се комбинират с виртуални клас-методи. Това дава същия ефект както използването на класове с виртуални методи - действителният метод, който трябва да бъде извикан, се определя по време на изпълнение.

[source,pascal]
----
type
  TMyClass = class(TComponent)
    class procedure DoSomething; virtual; abstract;
  end;

  TMyClass1 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClass2 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  ClassRef := TMyClass1;
  ClassRef.DoSomething;

  ClassRef := TMyClass2;
  ClassRef.DoSomething;

  { And this will cause an exception at runtime,
    since DoSomething is abstract in TMyClass. }
  ClassRef := TMyClass;
  ClassRef.DoSomething;
end;
----

Ако имате екземпляр и искате да получите препратка към неговия клас (не декларирания клас, а същинския клас използван при неговото конструиране), можете да използвате свойството `ClassType`. Типа на `ClassType` е `TClass`, който е деклариран като `class of TObject`. Често можете без проблем да го преобразувате към по-конкретен клас, ако ви е известно, че е екземплярът е нещо по-специфично от `TObject`.

Можете да използвате препратката от `ClassType` за извикване на виртуални методи, в това число виртуални конструктори. Това ви позволява да създадете метод `Clone`, който създава екземпляр от _точния клас на текущия обект_. Може да го комбинирате с <<Cloning: TPersistent.Assign>> за да получите метод, който връща нов "клонинг" на инстанцията от която е извикан. 

Не забравяйте, че това ще работи само когато конструкторът на вашия клас е виртуален. Например, може да се използва със стандартните наследници на `TComponent`, тъй като всички те трябва да заменят виртуалния конструктор `TComponent.Create(AOwner: TComponent)`.

[source,pascal]
----
type
  TMyClass = class(TComponent)
    procedure Assign(Source: TPersistent); override;
    function Clone(AOwner: TComponent): TMyClass;
  end;

  TMyClassRef = class of TMyClass;

function TMyClass.Clone(AOwner: TComponent): TMyClass;
begin
  // This would always create an instance of exactly TMyClass:
  //Result := TMyClass.Create(AOwner);
  // This can potentially create an instance of TMyClass descendant:
  Result := TMyClassRef(ClassType).Create(AOwner);
  Result.Assign(Self);
end;
----

// This is an example why compiler cannot detect *all* uses of an abstract
// methods at compile time, in this case --- the error can only resurface
// at runtime.
//
// Poor example actually, since compiler could prevent "ClassRef := TMyClass"
// in this case?

### Статични методи на клас

За да разберете _статичните методи на клас_, трябва да разберете как работят _нормалните методи на клас_ (описани в предишните раздели). Вътрешно, _нормалните методи на клас_ получават _референция_ към своя клас (тя се предава през скрит, неявно добавен параметър на метода). Тази препратка може да се използва с помощта на ключовата дума `Self` в метода на класа. Обикновено това е полезно: тази препратка към клас ви позволява да извиквате _виртуалните методи на класа_ (чрез _таблицата с виртуални методи_ на класа).

// Just like _instance virtual methods_, the _virtual class methods_ use some

Наличието на скрита препратка обаче, прави _методите на класа_ несъвместими с _процедурните променливи_. Следната програма *няма да може да се компилира*:

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
type
  TMyCallback = procedure (A: Integer);

  TMyClass = class
    class procedure Foo(A: Integer);
  end;

class procedure TMyClass.Foo(A: Integer);
begin
end;

var
  Callback: TMyCallback;
begin
  // Error: TMyClass.Foo not compatible with TMyCallback
  Callback := @TMyClass(nil).Foo;
end.
----

[NOTE]
====
Ако сте в режим _Delphi_ тогава ще можете да напишете `TMyClass.Foo` вместо грозното `TMyClass(nil).Foo` което е в горния пример. Трябва да се признае, че `TMyClass.Foo` изглежда много по-елегантно и също така се проверява по-добре от компилатора. Използването на `TMyClass(nil).Foo` е хак... за съжаление необходим (засега) в режима _ObjFpc_, който е представен в тази книга.

Във всеки случай, присвояването на `TMyClass.Foo` на `Callback` по-горе би _било неуспешно_ и в режим Delphi, поради абсолютно същите причини.
====

Горният пример не се компилира, защото типа на `Callback` не е съвместим с метода на класа `Foo`. Това е така, защото вътрешно методът `Foo` има този специален скрит _implicit_ параметър за препратката към класа.

Един от начините да коригирате горния пример е да  да се сппромените дефиницията на `TMyCallback` на следната: `TMyCallback = procedure (A: Integer) of object;`. Но понякога това не е желателно.

Другият начин е метода да се укаже като `static`. По същество такъв метод е просто глобална процедура / функция, с тази разлика, че видимостта му е ограничена вътре в класа. Той _няма_ такава скрита препратка към клас (по този начин _не може да бъде виртуален_ и _не може да извиква виртуални методи_). От друга страна, той е съвместим с нормалните (необектни) процедурни променливи. Така че това ще работи:

[source,pascal]
----
include::code-samples/static_class_method.lpr[]
----

### Полета и свойства на клас

_Полето на клас_ може да се дефинира в секция `class var` вътре в класа. То е подобно на обикновеното поле но няма нужда от инстанция за да се достъпва. Като резултат, то е подобно на глобална променлива но видимостта му е ограничена само в класа, в който е дефинирано.

_Свойството на клас_ е такова свойство, което може да се достъпи през референция на клас и без да е необходимо да има създаден екземпляр. Дефинира се с `class property` вместо само с `property` и с методи _getter_ и / или _setter_, които обаче трябва да са _статични клас-методи_. Виж <<Static class methods>>.  

По аналогия с обикновените свойства (see <<Properties>>), вместо да се укаже _статичен клас-метод_, може да се укаже и име на поле. То също трябва да бъде _поле на клас_. 

[source,pascal]
----
include::code-samples/class_properties.lpr[]
----
// NOTE: Why the _class properties_ have to be backed by _static class methods_, not _normal class methods_? Noone really knows (see http://lists.freepascal.org/pipermail/fpc-pascal/2017-February/050131.html , http://lists.freepascal.org/pipermail/fpc-pascal/2017-February/050135.html , https://www.mail-archive.com/fpc-devel@lists.freepascal.org/msg30511.html ), the initial implementation (Delphi) made it like that. Presumably for speed, or ease of implementation of the compiler.

### Помощници за клас

_Методът_ е просто процедура или функция вътре в класa. Извън класа го извиквате със специален синтаксис `MyInstance.MyMethod(...)`. След известно време привиквате да мислите, че _ако искам да извърша действие Action с инстанция X, пиша `X.Action(...)`_.

Но понякога трябва да кодирате нещо, което по смисъла си е _действие върху клас TMyClass_, но без да модифицирате изходния код на _TMyClass_. Понякога това е така, защото изходния код не е ваш и не искате да го променяте. Понякога това се дължи на някакви зависимости -- добавянето на нов метод като `Render` към клас `TMy3DObject` изглежда проста идея, но може би базовата реализация на класа `TMy3DObject` трябва да се поддържа независима от кода за изобразяване? Би било по-добре да "подобрите" съществуващ клас, да добавите функционалност към него, без да променяте изходния му код.

Простия начин да го направите е да създадете глобална процедура, която приема екземпляр на `TMy3DObject` като свой първи параметър.
 
[source,pascal]
----
procedure Render(const Obj1: TMy3DObject; const Color: TColor);
var
  I: Integer;
begin
  for I := 0 to Obj1.ShapesCount - 1 do
    RenderMesh(Obj1.Shape[I].Mesh, Color);
end;
----

Това работи идеално, но недостатъкът е, че извикването изглежда малко грозно. Докато обикновено извиквате действия като `X.Action(...)`, в този случай трябва да ги извиквате като `Render(X, ...)`. Би било добре да можете просто да напишете `X.Render(...)`, дори когато `Render` не е имплементирано в същия модул като `TMy3DObject`.

За това са пригодени _помощниците за клас_. Те са просто начин за прилагане на процедури / функции, които работят върху даден клас и които се извикват като нормални методи, но всъщност не са такива - те са добавени отвън към дефиницията на `TMy3DObject`.

[source,pascal]
----
type
  TMy3DObjectHelper = class helper for TMy3DObject
    procedure Render(const Color: TColor);
  end;

procedure TMy3DObjectHelper.Render(const Color: TColor);
var
  I: Integer;
begin
  { note that we access ShapesCount, Shape without any qualifiers here }
  for I := 0 to ShapesCount - 1 do
    RenderMesh(Shape[I].Mesh, Color);
end;
----

NOTE: По-общото понятие е _"Помощник за тип"_. Чрез тях можете да добавяте методи дори към примитивни типове, като цели числа или enum. Можете също да добавите _"помощници за запис"_ към (познахте...) записи. Вижте http://lists.freepascal.org/fpc-announce/2013-February/000587.html .
//And of course to records and old-style objects (both of them can also have regular methods, they are much like classes in this regard).

### Виртуални конструктори, деструктори

Името на деструктора е винаги `Destroy`, той е виртуален (защото трябва да се извика по време на изпълнение без да е известен точния клас) и е без параметри.

По конвенция името на конструктора е `Create`.

Можете да промените това име, но бъдете внимателни -- ако дефинирате `CreateMy`, винаги предефинирайте `Create`, в противен случай потребителят все още ще може да извика `Create` на предшественика, заобикаляйки по този начин вашия `CreateMy` конструктор.

В `TObject` той не е виртуален и когато създавате наследници, можете свободно да променяте параметрите му. Новият конструктор ще скрие конструктора в предшественика (забележка: не поставяйте `overload`, освен ако не искате да се счупи).

В наследниците на `TComponent` трябва да замените неговия `constructor Create(AOwner: TComponent);`. При сериализацията, за да създадете клас, без да знаете неговия тип по време на компилиране, наличието на виртуални конструктори е много полезно (виж <<Class references>> по-горе).

### Изключение в конструктор

Какво се случва, ако възникне изключение по време на изпълнението на конструктор? Редът:

[source,pascal]
----
X := TMyClass.Create;
----

в този случай не се изпълнява докрай, на `X` не може да се присвои стойност ... кой тогава ще почисти полусъздадената инстанция? 

Решението в Object Pascal е, че в случай, че възникне изключение в рамките на конструктор, тогава се извиква деструкторът. Това е причина, поради която _вашият деструктор трябва да е стабилен_, т.е. трябва да работи при всякакви обстоятелства, дори на полусъздадена инстанция на клас. Обикновено това е лесно, ако освобождавате всичко безопасно, като например чрез `FreeAndNil`.

Ние също трябва да разчитаме в такива случаи, че _паметта на класа е гарантирано нулирана точно преди кодът на конструктора да бъде изпълнен_. Знаем, че в началото всички препратки към клас са `nil`, всички цели числа са `0` и така нататък.

Така че долното ще работи без изтичане на памет:

[source,pascal]
----
include::code-samples/exception_in_constructor_test.lpr[]
----

## Интерфейси

### Bare (CORBA) interfaces

_An interface_ declares an API, much like a class, but it does not define the implementation. A class can implement many interfaces, but it can only have one ancestor class.

You can cast a class to any interface it supports, and then _call the methods through that interface_. This allows to treat in a uniform fashion the classes that don't descend from each other, but still share some common functionality. Useful when a simple class inheritance is not enough.

The _CORBA interfaces_ in Object Pascal work pretty much like interfaces in Java (https://docs.oracle.com/javase/tutorial/java/concepts/interface.html) or C# (https://msdn.microsoft.com/en-us/library/ms173156.aspx).

//This is much like Java, where interfaces are used whenever you think of multiple inheritance.

[source,pascal]
----
include::code-samples/interfaces_corba_test.lpr[]
----

### CORBA and COM types of interfaces

Why are the interfaces (presented above) called "CORBA"?::

  The name *CORBA* is unfortunate. A better name would be *bare interfaces*. These interfaces are a _"pure language feature"_. Use them when you want to cast various classes as the same interface, because they share a common API.
+
//The declaration `{$interface corba}` simply means that the declared interfaces *do not* automatically descend from the special `IUnknown` interface. Which in turn means that they *do not* by default have any extra baggage (like reference-counting found in the *COM* interfaces).
//+
While these types of interfaces can be used together with the _CORBA (Common Object Request Broker Architecture) technology_ (see https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture), they are _not_ tied to this technology in any way.

Is the `{$interfaces corba}` declaration needed?::

  Yes, because by default
//(if we would omit the `{$interfaces corba}` directive)
  you create _COM interfaces_. This can be stated explicitly by saying `{$interfaces com}`, but usually it's not needed since it's the default state.
+
And I don't advise using _COM interfaces_, especially if you're looking for something equivalent to interfaces from other programming languages. The _CORBA interfaces_ in Pascal are exactly what you expect if you're looking for something equivalent to the interfaces in C# and Java. While the _COM interfaces_ bring additional features that you possibly don't want.
+
Note that the `{$interfaces xxx}` declaration only affects the interfaces that do not have any explicit ancestor (just the keyword `interface`, not `interface(ISomeAncestor)`). When an interface has an ancestor, it has the same type as the ancestor, regardless of the `{$interfaces xxx}` declaration.

What are COM interfaces?::

  The _COM interface_ is synonymous with _an interface descending from a special `IUnknown` interface_. Descending from `IUnknown`:
+
* Requires that your classes define the `_AddRef` and `_ReleaseRef` methods. Proper implementation of these methods can manage the lifetime of your objects using the reference-counting.
* Adds the `QueryInterface` method.
* Allows to interact with the _COM (Component Object Model) technology_.

Why do you advise to not use the COM interfaces?::

  Because _COM interfaces_ "entangle" two features that should be unrelated (orthogonal) in my view: _multiple inheritance_ and _reference counting_. Other programming languages rightly use separate concepts for these two features.
+
To be clear: *reference-counting*, that provides an automatic memory management (in simple situations, i.e. without cycles), *is a very useful concept*. But *entangling this feature with interfaces (instead of making them orthogonal features) is unclean in my eyes*. It definitely doesn't match my use cases.
+
--
* Sometimes I want to cast my (otherwise unrelated) classes to a common interface.
* Sometimes I want to manage memory using the reference counting approach.
* _Maybe_ some day I will want to interact with the _COM technology_.
--
+
But these are all separate, unrelated needs. Entangling them in a single language feature is counter-useful in my experience. It does cause actual problems:
+
--
* If I want the feature of _casting classes to a common interface API_, but I don't want the reference-counting mechanism (I want to manually free objects), then the COM interfaces are problematic. Even when reference-counting is disabled by a special `_AddRef` and `_ReleaseRef` implementation, you still need to be careful to never have a temporary interface reference hanging, after you have freed the class instance. More details about it in the next section.
* If I want the feature of _reference counting_, but I have no need for an interface hierarchy to represent something different than the class hierarchy, then I have to duplicate my classes API in interfaces. Thus creating a single interface for each class. This is counter-productive. I would much rather have _smart pointers_ as a separate language feature, not entangled with interfaces (and luckily, it's coming:).
--
+
That is why I advise to use _CORBA_ style interfaces, and the `{$interfaces corba}` directive, in all modern code dealing with interfaces.
+
_Only if you need both "reference counting" and "multiple inheritance" at the same time, then use COM interfaces_. Also, Delphi has only COM interfaces for now, so you need to use COM interfaces if your code must be compatible with Delphi.

Can we have reference-counting with CORBA interfaces?::

  Yeah. Just add `_AddRef` / `_ReleaseRef` methods. There's no need to descend from the `IUnknown` interface. Although in most cases, if you want reference-counting with your interfaces, you may as well just use COM interfaces.
//    Stress that non reference counted interfaces are more "bare" and deemphasize the link to corba and java. Note that IUnknown doesn't just do ref-counting though, it also plays a part in identity (QueryInterface) that allows to get other interfaces supported by the object from the object. (e.g. to see if you can "upcast" an interface to a newer version)
//  Roger. The way I understand, the better names would be "always-descend-from-IUnknown" vs "don't-always-descend-from-iUnknown", not "COM" vs "CORBA". That would certainly be clearer for someone who is not interested in interacting with outside services (neither COM nor CORBA) and just wants a language feature (with the purpose of casting two classes to a common interface, because they share a common API, similar to interfaces in Java/C#).

### Interfaces GUIDs

GUIDs are the seemingly random characters `['{ABCD1234-...}']` that you see placed at every interface definition. Yes, they are just random. Unfortunately, they are necessary.

//Yes, they look ugly.
//, and I wish they would not be necessary.
The GUIDs have no meaning if you don't plan on integrating with communication technologies like _COM_ nor _CORBA_. But they are necessary, for implementation reasons. Don't be fooled by the compiler, that unfortunately allows you to declare interfaces without GUIDs.

Without the (unique) GUIDs, your interfaces will be treated equal by the `is` operator. In effect, it will return `true` if your class supports _any_ of your interfaces. The magic function `Supports(ObjectInstance, IMyInterface)` behaves slightly better here, as it refuses to be compiled for interfaces without a GUID. This is true for both CORBA and COM interfaces, as of FPC 3.0.0.

So, to be on the safe side, you should always declare a GUID for your interface. You can use _Lazarus_ GUID generator (`Ctrl + Shift + G` shortcut in the editor). Or you can use an online service like https://www.guidgenerator.com/ .

Or you can write your own tool for this, using the `CreateGUID` and `GUIDToString` functions in RTL. See the example below:

[source,pascal]
----
include::code-samples/gen_guid.lpr[]
----

### Reference-counted (COM) interfaces

The _COM interfaces_ bring two additional features:

. integration with COM (a technology from Windows, also available on Unix through _XPCOM_, used by Mozilla),
. reference counting (which gives you automatic destruction when all the interface references go out of scope).

// In my eyes, it was rather ugly to entangle _interfaces_ with such features. It complicates using the interfaces for the simple purpose: when multiple classes implement the same API, but cannot descend from a common class.
When using _COM interfaces_, you need to be aware of their _automatic destruction_ mechanism and relation to COM technology.

In practice, this means that:

// +
// The relation to COM technology has . The reference counting idea is baffling. Why would you connect one language feature, _interfaces_, with something so unrelated like _reference counting_? It seems, because the COM technology required it...

* Your class needs to implement a magic `_AddRef`, `_Release`, and `QueryInterface` methods. Or descend from something that already implements them. A particular implementation of these methods may actually enable or disable the __reference-counting__ feature of COM interfaces (although disabling it is somewhat dangerous -- see the next point).

** The standard class `TInterfacedObject` implements these methods to _enable_ the reference-counting.
** The standard class `TComponent` implements these methods to _disable_ the reference-counting. *In the Castle Game Engine* we give you additional useful ancestors `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent` for this purpose, see https://github.com/castle-engine/castle-engine/blob/0519585abc13e8386cdae5f7dfef6f9659dc9b57/src/base/castleinterfaces.pas .

//* You can turn off the reference-counting mechanism by simple `_AddRef`, `_Release` implementations that always return `-1`. Actually, the standard implementation of these methods in `TComponent`, `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent` already does this for you.

* You need to be careful of freeing the class, when it may be referenced by some interface variables. Because the interface is released using a virtual method (because it _may be reference-counted, even if you hack the _AddRef method to not be reference-counted..._), you cannot free the underlying object instance as long as some interface variable may point to it. See _"7.7 Reference counting"_ in the FPC manual (http://freepascal.org/docs-html/ref/refse47.html).
//, http://bugs.freepascal.org/view.php?id=10374 .

The safest approach to using _COM interfaces_ is to

* accept the fact that they are reference-counted,
* derive the appropriate classes from `TInterfacedObject`,
* and avoid using the class instance, instead accessing the instance always through the interface, letting reference-counting manage the deallocation.

This is an example of such interface use:

[source,pascal]
----
include::code-samples/interfaces_com_with_ref_counting.lpr[]
----

### Using COM interfaces with reference-counting disabled

As mentioned in the previous section, your class can descend from `TComponent` (or a similar class like `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent`) which disables reference-counting for COM interfaces. This allows you to use COM interfaces, and still free the class instance manually.

You need to be careful in this case to not free the class instance when some interface variable may refer to it. Remember that every typecast `Cx as IMyInterface` also creates a temporary interface variable, which may be present even until the end of the current procedure. For this reason, the example below uses a `UseInterfaces` procedure, and it frees the class instances _outside_ of this procedure (when we can be sure that temporary interface variables are out of scope).

To avoid this mess, it's usually better to use CORBA interfaces, if you don't want reference-counting with your interfaces.

[source,pascal]
----
include::code-samples/interfaces_com_test.lpr[]
----

### Typecasting interfaces

This section applies to both _CORBA_ and _COM_ interfaces (however, it has some explicit exceptions for CORBA).

1. Casting to an interface type using the `as` operator makes a check at run-time. Consider this code:
+
[source,pascal]
----
UseThroughInterface(Cx as IMyInterface);
----
+
It works for all `C1`, `C2`, `C3` instances in the examples in previous sections. If executed, it would make a run-time error in case of `C3`, that does not implement `IMyInterface`.
+
Using `as` operator works consistently regardless if `Cx` is declared as a class instance (like `TMyClass2`) or interface (like `IMyInterface2`).
+
However, it is not allowed for CORBA interfaces.

2. You can instead cast the instance as an interface implicitly:
+
[source,pascal]
----
UseThroughInterface(Cx);
----
+
In this case, the typecast must be valid at compile-time. So this will compile for `C1` and `C2` (that are declared as classes that implement `IMyInterface`). But it will not compile for `C3`.
+
In essence, this typecast looks and works just like for regular classes. Wherever an instance of a class `TMyClass` is required, you can always use there a variable that is declared with a class of `TMyClass`, *or `TMyClass` descendant*. The same rule applies to interfaces. No need for any explicit typecast in such situations.

3. You can also typecast using `IMyInterface(Cx)`. Like this:
+
[source,pascal]
----
UseThroughInterface(IMyInterface(Cx));
----
+
Usually, such typecasting syntax indicates an _unsafe, unchecked_ typecast. Bad things will happen if you cast to an incorrect interface. And that's true, if you cast _a class to a class_, or _an interface to an interface_, using this syntax.
+
There is a small exception here: if `Cx` is declared as a class (like `TMyClass2`), then this is a typecast that must be valid at compile-time. So casting _a class to an interface_ this way is a safe, fast (checked at compile-time) typecast.

To test it all, play around with this example code:

[source,pascal]
----
include::code-samples/interface_casting.lpr[]
----

## About this document

Copyright Michalis Kamburelis.

The source code of this document is in AsciiDoc on https://github.com/michaliskambi/modern-pascal-introduction. Suggestions for corrections and additions, and patches and pull requests, are always very welcome:) You can reach me through GitHub or email michalis@castle-engine.io. My homepage is https://michalis.xyz/. This document is linked under the _Documentation_ section of the _Castle Game Engine_ website https://castle-engine.io/.

You can redistribute and even modify this document freely, under the same licenses as Wikipedia https://en.wikipedia.org/wiki/Wikipedia:Copyrights :

* _Creative Commons Attribution-ShareAlike 3.0 Unported License (CC BY-SA)_
* or the _GNU Free Documentation License (GFDL) (unversioned, with no invariant sections, front-cover texts, or back-cover texts)_ .

Thank you for reading!
